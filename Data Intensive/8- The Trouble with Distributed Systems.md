
تا اینجا ما در مورد فالت های زیادی حرف زدیم. باید بگم که تا اینجا خیلی خوشبین بودیم. واقعیت از انچه گفتیم دارک تر هست. ازین به بعت بیشتر بدبین خواهیم بود و فرض مون این خواهد بود که هر چیزی که ممکن است اشتباه پیش برود، قطعا اشتباه پیش خواهد رفت.

کار کردن با سیستم های توزیع شده قطعا سخت تر هست از نوشتن یه برنامه نرم افزاری برای یک سینگل کامپیوتر. دلیلش هم اینه که در سیستم های توزیع شده خیلی چیزا هستن که ممکنه منجر به خطا بشن. در انی فصل بیشتر درین مورد صحبت میکنیم.


## Faults and Partial Failures
در سیستم های توزیع شده ممکنه یه بخشی هایی از سیستم به صورت کاملا غیر قابل پیش بینی خراب بشه. در حالی که بخش های دیگری دارن درست کار میکنن. به ااین اتفاق میگن partial failure. دشواری قضیه اینجاست که کاملا nondeterministic هست. سیستم یه موقعی کار میکنه. یه موقعی fail میکنه. گاهی اصلا نمیشه فهمید آیا یه کار درست انجام شد یا fail شد.


## Cloud Computing and Supercomputing

طیفی از فلسفه ها در مورد چگونگی ساخت سیستم های محاسباتی در مقیاس بزرگ وجود دارد:
در یک سر طیف ابرکامپیوترها قرار دارن که هزاران پردازنده برای کارهای محاسباتی فشرده دارند.
در سر دیگر طیف cloud computing قرار داره که مربوط میشن به دیتاسنترهای 
در یک انتهای مقیاس، حوزه محاسبات با عملکرد بالا (HPC) قرار دارد. ابرکامپیوترها با هزاران CPU معمولاً برای کارهای محاسباتی علمی فشرده، مانند پیش‌بینی آب و هوا یا دینامیک مولکولی (شبیه‌سازی حرکت اتم‌ها و مولکول‌ها) استفاده می‌شوند.


در یک سوپرکامپیوتر، یه جاب معمولا هر از چندگاهی وضعیت محاسبات خودش رو به عنوان checkpoint  یه جا ذخیره میکنه. هرزمان یه نود دچار مشکل شد کل سیستم رو استاپ میکنه. بعد از تعمیر ان نود مشکل دارن، محاسبات رو از همان نقطه checkpoint ادامه میده. بنابراین سوپرکامیوتر ها بیشتر شبیه سینگل نود هستن تا توزیع شده. این سیستم ها یه partial failure رو مشابه یه total failure باهاش رفتار میکنن.

در این کتاب ما بیشتر روی سیستم هایی تمرکز داریم که سرویس های تحت وب میدن و معموا با سوپرکامیوتر ها متفاوتن.

سیستم های سرویس های آنلاین میدن براشون latency خیلی مهمه و نمیتونن برای یه partial failure کل سیستم رو متوقف کنن تا مشکل رو حل کنند. این سیستم ها با سیستم هایی که کارشون رو به صورت batch انجام میدن فرق دارن.

در سوپرکامیوترها سخت افزارهای مخصوصی به کار میره. هر نود تقریبا reliable هست. ارتباط نود ها بیشتر از طریق shared memory و remote direct memory access هست

اگر میخواهیم سیستم های توزیع شده بسازیم باید partial failure رو بپذیریم و تلاش کنیم سیستم  fault-tolerance طراحی کنیم.

حتی در سیستم های کوچیک که تعدا کمی نود دارند هم باید فکری برای partial failure کرده باشیم.

 هندل کردن فالت ها بادی بخضی از طراحی مون باشه در سیستم های توزیع شده.

اینجا داره میگه چطور ممکنه تو سیستمی که المان هاش قابل اعتماد نیستن، بتونیم توتالی سیستم رو reliable 

## Unreliable Networks


در این کتاب منظورمون از سیستم های توزیع شده سیستم های shared-nothing  هستن که از طریق نتوورک با هم ارتباط دارن.

ایمجا داره میگه چرا بیشتر از سیستم های Shared-nothing برای سیستم های توزیع شده استفاده میشه. چون ارزان تر هستن به خاطر اینکه سخت افزار خاض و پیچیده ای لازم ندارن.

در شبکه اینترنت که از نوع asynchronous packet network هست وقتی یه بسته ای ارسال میشه شبکه اصلا تضمین نمیده که اون بسته رو به مقصد برسونه. وقتی شما بسته ای رو ارسال میکنی و انتظار جواب داری:
۱- درخواستت ممکنه گم بشه
۲- درخواستت ممکنه تو یه صف شلوغی گیر کنه و دیر به مقصد برسه
۳- نود مقصد ممکنه از کار افتاده باشه
۴- نود مقصد ممکنه موقتا پاسخ دهی رو متوقف کرده باشه (مثلا یه پروسه طولانی برای  garbage collection ران کرده)
۵- نود مقصد درخواست شما رو گرفته و جواب هم داده ولی پاسخ شما در شبکه گم شده
۶- نود مقصد درخواست شما رو گرفته و پردازش هم کرده و جواب هم داده ولی پاسخ به دلایل مختلف مثلا شلوغی شبکه یا شلوغی خود شما دیر به دستتون میرسه



![[Pasted image 20250203150831.png]]




این مسائل در نتوورک های آسینک وجود دارن. وقتی درخواستی فرستادی و جوابی نگرفتی اصلا نمیتونی متوجه بشی دقیقا چرا جواب نگرفتی.

یه راه برای هندل کردن این بلاتکلیفی استفاده کردن از timeout هست. اگر مدت زمانی به اندازه timeout گذشت و جوابی نگرفتیم نتیجه میگیریم که قرار نیست جوابی بگیریم.

## Network Faults in Practice
شواهد و قراین نشون میده که هنوز هم همچنان نتوورک مستئد فالت هست، با وجود اینکه دهه ها هست که از پیدایش نتوورک میگذره.
در این پاراگراف داره چند نمونه مطالعه در این زمینه رو اشاره میکنه.

وقتی ارتباط یه بخشی از نتوورک از بخش دیگری قطع میشه میگن Network partitions اتفاق افتاده و یا netsplit. اما برای اینکه با پاژه پارتیشن در مبحث شاردینگ استباه نشه اینجا کلا به این مشکلات میگیم network fault.

 حتی اگر نرخ خرابی نتوورک کم هست باز هم اپلیکیشن شما باید بتونه این خرابی ها رو هندل کنه.
اگر اپلیکیشن مشا خرابی های شبکه ای رو هندل نکنه ممکنه اتفاقات بدی به دنبال خرابی شبکه رخ بده. مثلا یه کلاستر ممکنه به deadlocked برسه و  و دیگه نتونه به ریکوئست ها جواب بده حتی بعد از اینکه مشکل نتوورک حل بشه. یا ممکنه تمام دیتا و اطلاعات شما رو دیلیت کنه.

درضمن اپلیکیشن شما نه تنها باید بتونه خرابی های شبکه رو هندل بکنه بلکه باید بتونه به کاربر هم خطای مناسبی نشون بده

## Detecting Faults


خیلی از سیستم ها نیاز دارن که بتونن به صورت اتوماتیک نودهایی که دچار مشکل شده را شناسایی کنند. برای مثال:
یه لودبالانسر لازمه نود مرده یا شناسایی کنه تا لودی سمت آن نفرسته
در دیتابیس های توزیع شده تک لیدری،اگر لیدر از کار بیفته یکی از فالوورها باید متوجه و سریع  جای لیدر بشینه

متاسفانه انقدر در شبکه عدم قطعیت وجود داره که به این راحتی نمیشه متوجه شد نودی از کار افتاده یا نه. ولی در بعضی شرایط میشه یه سری فیدبک دریافت کرد که اینو نشون بدن:
- مثلا روی یه نود پراسس پاسخ دهنده crash کرده ولی سیستم عامل در حال اجراست. مثلا تو این شرایط بشه یه اسکریپتی داشت که به نودهای دیگه خبر بده که پراسس از کار افتاده
- یا مثلا فرض کنید شما دسترسی دارین به management interface نتوورک تون اینجوری مینین کوئری بزنین و از لینک های خراب مطلع بشین
- یا یه روتر اگر مطمسن بشه که نودی که شما دارین بهش درخواست میزنین در دسترس نیست خودش میتونه به شما پاسخ بده با یه ICMP Destination Unreachable packet.


اینکه از نودهای down شده سریع فیدبک بگیریم خیلی مفیده ولی نمیشه روش حساب کرد.


## Timeouts and Unbounded Delays

