Understanding internal storage mechanisms helps developers choose and tune the appropriate storage engine for their applications. The chapter will explore storage engines optimized for transactional versus analytical workloads, starting with traditional relational and most NoSQL databases, specifically examining log-structured and page-oriented storage engines like B-trees.

# Data Structures That Power Your Database
A simple database can be implemented with two Bash functions: `db_set` to append key-value pairs to a file, and `db_get` to retrieve the latest value for a key by scanning the file. This approach is efficient for appending data but inefficient for lookups, as it requires scanning the entire file. Efficient data retrieval requires indexes, which provide metadata to locate data quickly. Indexes speed up read queries but slow down writes, necessitating careful selection based on query patterns to balance performance and overhead.

## Hash Indexes
Indexes for key-value data are essential for efficient retrieval. A simple approach involves appending key-value pairs to a file and maintaining an in-memory hash map to track byte offsets. This method is effective for high-performance reads and writes if all keys fit in memory. To manage disk space and performance, logs can be segmented and compacted, merging segments to keep lookups efficient. While this approach simplifies concurrency and crash recovery, it has limitations: the hash map must fit in memory, and range queries are inefficient. More advanced indexing structures can address these issues.
