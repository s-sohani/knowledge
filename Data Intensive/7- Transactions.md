هر آن ممکنه خود دیتابیس وسط کار خراب بشه، اپلیکیشن کرش کنه، نتوورک دچار مشکل بشه، کلاینت ها همزمان بخوان یه دیتا رو تغییر بدن و ...
سیستم باید در مقابل همه این مشکلات احتمالی fault tollerant باشه.
برای چندین دهه transactions راه حلی برای این مشکلات احتمالی بودن. 
اگر سال هاست داریم با transactions کار میکنیم ممکنه خیلی بهشون سطحی نگاه کنیم و حواسمون نباشه که چه کمکی به ما میکنند در پیاده سازی اپلیکیشن ها. 
البته هر اپلیکیشنی بیاز به transactions نداره یا ممکنه براش خوب باشه که از transactions استفاده نکنه. مثلا وقتی که میتونه بدون استفاده از transactions پرفورمنس یا availability بالاتری داشته باشه.
شما چطورم یتونی تشخیص بدی که آیا به transactions نیاز داری یا نه؟ برای پاسخ به این سوال ما نیاز داریم اول بدونیم transactions چه قابلیت هایی به ما میدن و در مقابل چه هزینه هایی برای ما دارن؟ و اینکه در نگاه اول transactions خیلی ساده و سرراست به نظر میان ولی خیلی جزئیات ظریفی دارن که باید بدونیم.

تو این فصل قراره در مورد کلیه مباحث حول transactions صحبت کنیم.

# The Slippery Concept of a Transaction

امروزه خیلی از دیتابیس های relational و حتی برخی از nonrelational ها از transactions پشتیبانی میکنند. اغلب هم از همون تعریف و استایلی استفاده میکنند کهع اولین بار در سال ۱۹۷۵ توسط IBM تعریف شد.
در سال ۲۰۰۰ دیتابیس های nonrelational محبوب شدند. هدف اونها معرفی کردن دیتامدل جدید در کنار رپلیکیشن و پارتیشنینگ بود. بحث Transactions برای اونها مزاحمت به حساب میومدن در نتیجه این نسل جدید از دیتابیس ها کلا Transactions را کنار گذاشتند.
با هیاهوی این دیتابیس های توزیع شده، این باور عمومی شکل گرفت Transactions با scalability, منافات دارن و هر سیستم در مقیاس بزرگ باید scalability, را به منظور حفظ performance و availabilityا کنار بگذارد.
بریم ببینیم transactions چه خوبی و بدی هایی دارند.

# The Meaning of ACID
ویژگی transactions معمولا با کلمه ACID شرح داده میشه:
ACID : Atomicity, Consistency, Isolation, Durability

در عمل پیاده سازی خواص ACID توسط دیتابیس های مختلف متفاوت هست. برای همین وقتی یک دیتابیس ادعا میکنه که خاصیت ACID داره نمیشه گفت دقیقا چیارو گارانتی میکنه.

دیتاسیستمی که خاصیت ACID نداره گاها BASE می نامند یعنی:
Basically Available, Soft state, Eventual consistency


## Atomicity
Atomicity
یعنی چیزی که نمیشه بشکنیمش به بخش های کپچیک تر.
مثلا در برنامه multi-threaded  که یکی از threaded ها داره چندتا کار به صورت Atomic انجام میده، هرگز یک thread دیگه نمیتونه نتایج نیمه کاره ترد مورد نظر رو ببینه. 

البته در موضوع ACID برای تعریف Atomicity اصلا به concurrency. اشاره نمیشه. در این بحث Atomicity میگه وقتی یک کلاینت چندتا دیتا رو میخواد به صورت Atomic بنویسه اگر در وسط این عملیات هر مشکلی پیش بیاد transaction نمیتونه کامل (کامیت‌) بشه بلکه aborted میشه و اون چندتا دیتای کلاینت باید رول بک بشن. 
بدون atomicity اگر وسط چندتا عمل atomic یه مشکلی پیش میامد نمیدونستیم دقیقا چه تغییراتی اعمال شده و باید discard بشن. 

میشه گفت یه واژه معادل برای اتومیسیتی ، abortability هست.
## Consistency

Consistency
در جاهای متفاوتی استفاده شده که معنایش در هر مورد تقاوت های ظریفی با هم داره

در بحث رپلیکیشن موضوع eventual consistency رو داشتیم
در بحث پارتیشنینگ برای پارتیشن بندی با هش کلید بحث Consistent hashing بود
در تئوری CAP (مربوط به فصل ۹) اونو به معنی linearizability خواهیم داشت
و در بحث تراکنش ها و خاصیت ACID معنای دیگه ای میده. 

consistency
در بحث ACID یعنی دیتاهای ما که در دیتابیس قرار دارند باید همیشه در وصعیت خوبی قرار داشته باشند. این وضعیت خوب متناسب با هر اپلیکیشنی تعریف می شود. 
مثلا اگر مبلغی قرار هست بین دوتا اکانت جابه جا شود، باید مجموع موجودی آن دو اکانت قبل و بعد از تراکنش یکسان باشد.



البته در مورد consistency این اپلیکیشن هست که باید بتواند transaction های درستی تعریف کند . در این زمینه دیتابیس هیچ تضمینی نمیده. در حالی که اون سه خاصیت دیگه یعنی Atomicity, isolation, and durability رو دیتابیس داره فراهم میکنه.

## Isolation

اگر همزمان دوتا کلاینت بخواهند یک رکورد رو تغییر بدهند مسال هrace conditions رخ میده.
شکل ۷-۱ داره یه مساله race conditions رو نشون میده.
در موضوع ACID مورد Isolation اینو میگه که تراکنش های موازی از هم ایزوله هستن.
در تعاریف کلاسیک به این ویژگی serializability هم میگفتن. چون وقتی transaction ها اجرا و کامیت میشن نتیجه نهایی طوری هست که انگار transaction ها کاملا به طور سریالی و متوالی اجرا شدند. با اینکه در حقیقت موازی اجزا شدند نه متوالی.

![[Pasted image 20241007133617.png]]

serializable isolation
به ندرت استفاده میشه چون خیلی پرفورمنس رو کاهش میده.
مثلا اوراکس اصلا همچین خاصیتی رو پیاده سازی نکرده. اوراکل یه مدل آیزوبیشن داره به نام serializable ولی در حقیقت داره اونو به روش snapshot isolation پیاده سازی میکنه. در ادامه جزئیاتشو میبینیم.

## Durability
Durability
میگه دیتابیس قول میده که وقتی یک transaction با موفقیت کامیت شد، هر دیتایی که آن نوشته است ماندگار میشه و دیگه نگران از بین رفتن آن دیتا نباشید.
وقتی دیتابیس سینگل نود هست، Durability یعنی دیتای کامیت شده روی یک استوریج غیر فرار مثل هارد نوشته شده.
وقتی دیتابیس رپلیکیشن دارد، Durability یعنی دیتا با موفقیت روی تمام نودها کپی شده است.

واقع بینانه نگاه کنیم ما Durability پرفکت نداریم چون اگر به هر دلیلی تمام کپی های دیتا از بین بروند دیتا از دست رفته است. درواقع داریم یه سری تکنیک ها با هدف risk-reduction به کار میگیریم.

# Single-Object and Multi-Object Operations
اینجا هم باز به تکرار دو موضوع isolation و atomicity رو توضیح میده.

اگر کلاینت در قالب یه تراکنش میخواهد چندین رکورد از دیتابیس رو تغییر بده مربوط میشه به موضوع Multi-Object Operations.
شکل ۷-۲ مربوط به یک اپلیکیشن ایمیل هست. تعداد ایمیل های ناخوانده کاربر با این کوئری که در این پاراگراف هست شمرده میشه.

در این شکل کاربر ۱ یک ایمیل به کار ۲ میده. برای این کار دوتا دیتا در دیتابیس درج میشه. یکی آبجکت ایمیل که در تیبل emails اضافه میشه و دیگری ++ کردن unread counter که در تیبل mailboxes درج میشه. ولی چون اینجا خاصیت isolation نداشتیم وسط این دوتا عمل، کاربر ۲ اومد و ایمیل رو در اینباکس خودش دید در عین حال unread counter رو صفر مشاهده کرد. در واقع کاربر ۲ در این سناریو ا انومالی dirty read مواجه شد. او تونست تغییرات کاربر ۱ را بدون اینکه عملیاتش به طور کامل تمام شود مشاهده کند.


![[Pasted image 20241007133714.png]]

![[Pasted image 20241007133725.png]]

در شکل ۷-۳ داره نیاز به atomicity رو نشون میده. اگر هرجایی از این تراکنش مولتی آبجکت عملیات موفق نباشد هردوی آنها باید رول بک شوند.

در تراکنش های مولتی آبجکت باید بتونیم عملیات خواندن و نوشتنی که متعلق به یک تراکنش هستند را تشخیص بدیم.

در دیتابیس های رابطه ای این کار معمولا از روی کانکشن TCP  کلاینت شناسایی میشه.  روی هر کانکشنی کلیه عملیاتی که مابین BEGIN TRANSACTION  و COMMIT انجام میشن متعلق به یک تراکنش هستند.

بسیاری از دیتابیس های غیر رابطه ای  راهی ندارند که بخوان عملیات دیتابیسی را به هم گروپ کنند. حتی اگر یک API از نوع مولتی آبجکت باشه هم نیاز نیست اونها در قالب تراکنش محسوب بشن.

## Single-object writes

نوشتن های سینگل آبجکت:
حتی وقتی یک تراکنش از نوع سینگل آبجکت هست هم نیاز به خاصیت های Atomicity و isolation وجود داره. مثلا فرض کنید تراکنش نوشتن یک داکیومنت ۲۰ کیلوبایتی می باشد.

اگر وسط نوشتن دیتای ۲۰ کیلوبایتی مشکل شبکه ای یا مشکل دیتابیسی پیش بیاد چکار باید کرد؟ 

چون این مسائل خیلی پیچیده هستن، اغلب دیتابیس ها میان atomicity و isolation رو فقط روی سینگل آبجکت و روی یک نود فراهم میکنند. atomicity رو میان با کمک log برای مواقع ریکاوری کردن crash فراهم میکنند و isolation را با lock کردن هر آبجکت.


برخی دیتابیس ها هم میان عملیات اتومیک پیچیده ای رو اراسه میدن. مثلا از عمل پلاس پلاس پشتیبانی میکنند.  دیگه اینجوری نیازی نیست که برای increment سیکل read-modify-write انجام بشه. مشابه همین عملیات compare-and-set هم هست که برخی دیتابیس ها پشتیبانیش میکنند.
این عملیات چون سینگل آبجکت هستن رو میشه به عنوان light‐weight transactions هم دانست.

## The need for multi-object transactions
 خیلی از دیتابیس های توزیع شده کلا تراکنش های مولتی آبجکت رو پشتیبانی نمیکنند چون پیاده سازیش پیچیدس و اینکه این پیچیدگی ها با availability و performance منافات دارند. ولی در کل مانع خاصی وجود نداره که نشه در حالت توزیع شده تراکنش ها رو هم پشتیبانی کرد. در فصل ۹ transaction های توزیع شده رو خواهیم دید.
آیا اصلا ما نیازی به تراکنش های مولتی آبجکت داریم؟ ایا میشه هر اپلیکیشنی را با دیتا مدل key-value  و عملیات سینگل آبجکتی پیاده سازی کرد؟
در دیتابیس های رابطه ای یک رکورد معمولا foreigh-key داره به یک رکورد دیگر در تیبل دیگر. تراکنش های مولتی آبجکت این تضمین رو به شما میده که این رفرنس ها خراب نشن.در دیتامدل های داکیومنتی رابطه جوین بین داکیومنت ها ندارند. داکیومنت های به صورت سینگل آبجکت آپدیت میشن. هرچند گاهی داکیومنت ها نرمالایز شده نیستن و redundancy  داریم و یه آپدیت روی یک داکیومنت لازم داره یه جای دیگه یه داکیومنت دیگه هم آپدیت بشه. در این شرایط هم Transaction ها میتونن کمک کننده باشن.

در دیتابیس هایی که secondary index دارند هم وقتی رکوردی آپدیت میشه لازمه ایندکس های ثانویه هم اپدیت بشن. اینجا هم نیاز به وجود transaction داریم که آپدیت ایندکس ها حتما به همراه آپدیت رکورد اصلی انجام بشه.

## Handling errors and aborts
ویژگی ACID تراکنش ها باعث میشه وقتی مشکلی پیش میاد عملیات ان تراکنش به طور کامل abort بشه و بشه با خیال راحت اونو از اول تکرار کرد.
همه دیتابیس ها از قانون ACID پیروی نمیکنند. به خصوص دیتابیس های رپلیکیشن شده به روش بدون لیدر بر اساس best effor کار میکنند. یعنی دیتابیس تمام تلاش خودشو میکنه که هم هچیز درست پیش بره ولی اگر مشکلی پیش بیاد هیچ کاری در راستای UNDO کردن انجام نمیده. در نتیجه خود اپلیکیشن باید خطا رو ریکاور کنه.
خطا اجتناب ناپذیره اما دولوپرها ترجیح میدن همیشه فکر کنن اپلیکیشن قراره روی هپی ترین مسیر حرکت کنه. برخی از ORM ها مثل اونایی که هایلایت شدن نمیان تراکنش های abort  شده رو دوباره تکرار کنن بلکه میان یه اکسپشن به لایه بالاتر پرتاب میکنن. 
هرچند تکرار دوباره تراکنش abortشده میتونه یه روش error handling باشه اما نه همیشه. در موارد زیر تکرار تراکنش abort شده راه حل درستی نیست.

- فرض کنید تراکنش به درستی انجام شده ولی به دلیل مشکل شبکه ای اپلیکیشن فکر میکند تراکنش abort شده
- اگر دیتابیس overload شده و برای همین نتونسته تراکنش رو انجام بده. تکرارش اوضاع رو بدتر میکنه
- گاهی تکرار تراکنش مشکل رو حل نمیکنه چون علت abort شدن تراکنش یه مساله permanent هست 
- اگر تراکنش یه side-effect خارج از دیتابیس داشته باشه ثلا در میانه تراکنش ایمیلی به کلاینت ارسال میشه. تکرار تراکنش abort شده باعث ارسال ایمیل تکراری میشه. اینجا بحث Two Phase Commint مطرح میشه که در صفحه ۳۵۴ قراره در موردش صحبت بشه


# Weak Isolation Levels
چون پیشگیری از race condition سمت اپلیکیشن و توسط دولوپری کار راحتی نیست و خیلی قابل تست نیست در نتیجه دیتابیس ها سعی میکنند این مساله را خودشان هندل کنند. قوی ترین سطح isolation در دیتابیس حالت serializable هست ولی چون هزینه پرفورمنسی بالایی دارد خیلی دیتابیس ها زیر بارش نمیرن. به جاش میان از متدهای ظعیف تر isolation استفاده میکنند. این روش های ضعیف تر بسیار امکان خطا و خراب شدن داده دارند در نتیجه اگر اپلیکیشن مالی دارین بهتره از دیتابیس های رابطه ای استفاده کنید.

در ادامه به چندتا از روش های Weak Isolation اشاره خواهد شد.

# Read Committed
Read Committed
این متد گارانتی میکنه که:
- شما هنگام خوندن از دیتابیس، فقط تغییرات کامیت شده را روی دیتابیس مشاهده خواهید کرد. امکان dirty reads نداریم.
- شما هنگام نوشتن روی دیتابیس فقط قادر خواهید بود دیتاهایی رو بنویسید که تا اون لحظه کامیت شده اند. امکان dirty writes نداریم.
.
در این شکل تا زمانی که کاربر ۱ کامیت نکده اثر تراکنشش توسط کاربر ۲ مشاهده نمیشود.
![[Pasted image 20241007134051.png]]

اینجا داره توضیح میده که چرا dirty read بد هست.

## No dirty writes
وقتی دو تا تراکنش همزمان میخوان یه دیتا رو تغییر بدن:
اولی وسط تراکنش هست و هنوز کامیت نکرده، دومی بیاد و تغییرات کامیت نشده اولی رو overwrite کنه (dirty write). وقتی دیتابیس قابلیت read committed isolation داره در این سناریو اجازه نمیده تراکنش دوم دیتا بنویسه تا زمانی که تراکنش اول یا کامیت بشه یا abort. 
در شکل ۷-۱ هم که دوتا کلاینت همزمان میخواستن یه دیتا رو پلاس پلاس کنند. در اون شرایط با داشتن read committed مشکل حل نمیشه. در مبحث Preventing Lost Updates به موضوع counter increments safe خواهیم پرداخت.

دو نفر همزمان میخواست یه ماشین رو بخرن. چون احتمال dirty write وجو داشت در نهایت خریدار ماشین در دیتابیس به نام Bob خورده ولی صورت حساب به نام Alice صادر شده است.

![[Pasted image 20241007134208.png]]

## Implementing read committed
