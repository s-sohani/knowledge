هر آن ممکنه خود دیتابیس وسط کار خراب بشه، اپلیکیشن کرش کنه، نتوورک دچار مشکل بشه، کلاینت ها همزمان بخوان یه دیتا رو تغییر بدن و ...
سیستم باید در مقابل همه این مشکلات احتمالی fault tollerant باشه.
برای چندین دهه transactions راه حلی برای این مشکلات احتمالی بودن. 
اگر سال هاست داریم با transactions کار میکنیم ممکنه خیلی بهشون سطحی نگاه کنیم و حواسمون نباشه که چه کمکی به ما میکنند در پیاده سازی اپلیکیشن ها. 
البته هر اپلیکیشنی بیاز به transactions نداره یا ممکنه براش خوب باشه که از transactions استفاده نکنه. مثلا وقتی که میتونه بدون استفاده از transactions پرفورمنس یا availability بالاتری داشته باشه.
شما چطورم یتونی تشخیص بدی که آیا به transactions نیاز داری یا نه؟ برای پاسخ به این سوال ما نیاز داریم اول بدونیم transactions چه قابلیت هایی به ما میدن و در مقابل چه هزینه هایی برای ما دارن؟ و اینکه در نگاه اول transactions خیلی ساده و سرراست به نظر میان ولی خیلی جزئیات ظریفی دارن که باید بدونیم.

تو این فصل قراره در مورد کلیه مباحث حول transactions صحبت کنیم.

# The Slippery Concept of a Transaction

امروزه خیلی از دیتابیس های relational و حتی برخی از nonrelational ها از transactions پشتیبانی میکنند. اغلب هم از همون تعریف و استایلی استفاده میکنند کهع اولین بار در سال ۱۹۷۵ توسط IBM تعریف شد.
در سال ۲۰۰۰ دیتابیس های nonrelational محبوب شدند. هدف اونها معرفی کردن دیتامدل جدید در کنار رپلیکیشن و پارتیشنینگ بود. بحث Transactions برای اونها مزاحمت به حساب میومدن در نتیجه این نسل جدید از دیتابیس ها کلا Transactions را کنار گذاشتند.
با هیاهوی این دیتابیس های توزیع شده، این باور عمومی شکل گرفت Transactions با scalability, منافات دارن و هر سیستم در مقیاس بزرگ باید scalability, را به منظور حفظ performance و availabilityا کنار بگذارد.
بریم ببینیم transactions چه خوبی و بدی هایی دارند.

# The Meaning of ACID
ویژگی transactions معمولا با کلمه ACID شرح داده میشه:
ACID : Atomicity, Consistency, Isolation, Durability

در عمل پیاده سازی خواص ACID توسط دیتابیس های مختلف متفاوت هست. برای همین وقتی یک دیتابیس ادعا میکنه که خاصیت ACID داره نمیشه گفت دقیقا چیارو گارانتی میکنه.

دیتاسیستمی که خاصیت ACID نداره گاها BASE می نامند یعنی:
Basically Available, Soft state, Eventual consistency


## Atomicity
Atomicity
یعنی چیزی که نمیشه بشکنیمش به بخش های کپچیک تر.
مثلا در برنامه multi-threaded  که یکی از threaded ها داره چندتا کار به صورت Atomic انجام میده، هرگز یک thread دیگه نمیتونه نتایج نیمه کاره ترد مورد نظر رو ببینه. 

البته در موضوع ACID برای تعریف Atomicity اصلا به concurrency. اشاره نمیشه. در این بحث Atomicity میگه وقتی یک کلاینت چندتا دیتا رو میخواد به صورت Atomic بنویسه اگر در وسط این عملیات هر مشکلی پیش بیاد transaction نمیتونه کامل (کامیت‌) بشه بلکه aborted میشه و اون چندتا دیتای کلاینت باید رول بک بشن. 
بدون atomicity اگر وسط چندتا عمل atomic یه مشکلی پیش میامد نمیدونستیم دقیقا چه تغییراتی اعمال شده و باید discard بشن. 

میشه گفت یه واژه معادل برای اتومیسیتی ، abortability هست.
## Consistency

Consistency
در جاهای متفاوتی استفاده شده که معنایش در هر مورد تقاوت های ظریفی با هم داره

در بحث رپلیکیشن موضوع eventual consistency رو داشتیم
در بحث پارتیشنینگ برای پارتیشن بندی با هش کلید بحث Consistent hashing بود
در تئوری CAP (مربوط به فصل ۹) اونو به معنی linearizability خواهیم داشت
و در بحث تراکنش ها و خاصیت ACID معنای دیگه ای میده. 

consistency
در بحث ACID یعنی دیتاهای ما که در دیتابیس قرار دارند باید همیشه در وصعیت خوبی قرار داشته باشند. این وضعیت خوب متناسب با هر اپلیکیشنی تعریف می شود. 
مثلا اگر مبلغی قرار هست بین دوتا اکانت جابه جا شود، باید مجموع موجودی آن دو اکانت قبل و بعد از تراکنش یکسان باشد.



البته در مورد consistency این اپلیکیشن هست که باید بتواند transaction های درستی تعریف کند . در این زمینه دیتابیس هیچ تضمینی نمیده. در حالی که اون سه خاصیت دیگه یعنی Atomicity, isolation, and durability رو دیتابیس داره فراهم میکنه.

## Isolation

اگر همزمان دوتا کلاینت بخواهند یک رکورد رو تغییر بدهند مسال هrace conditions رخ میده.
شکل ۷-۱ داره یه مساله race conditions رو نشون میده.
در موضوع ACID مورد Isolation اینو میگه که تراکنش های موازی از هم ایزوله هستن.
در تعاریف کلاسیک به این ویژگی serializability هم میگفتن. چون وقتی transaction ها اجرا و کامیت میشن نتیجه نهایی طوری هست که انگار transaction ها کاملا به طور سریالی و متوالی اجرا شدند. با اینکه در حقیقت موازی اجزا شدند نه متوالی.

![[Pasted image 20241007133617.png]]

serializable isolation
به ندرت استفاده میشه چون خیلی پرفورمنس رو کاهش میده.
مثلا اوراکس اصلا همچین خاصیتی رو پیاده سازی نکرده. اوراکل یه مدل آیزوبیشن داره به نام serializable ولی در حقیقت داره اونو به روش snapshot isolation پیاده سازی میکنه. در ادامه جزئیاتشو میبینیم.

## Durability
Durability
میگه دیتابیس قول میده که وقتی یک transaction با موفقیت کامیت شد، هر دیتایی که آن نوشته است ماندگار میشه و دیگه نگران از بین رفتن آن دیتا نباشید.
وقتی دیتابیس سینگل نود هست، Durability یعنی دیتای کامیت شده روی یک استوریج غیر فرار مثل هارد نوشته شده.
وقتی دیتابیس رپلیکیشن دارد، Durability یعنی دیتا با موفقیت روی تمام نودها کپی شده است.

واقع بینانه نگاه کنیم ما Durability پرفکت نداریم چون اگر به هر دلیلی تمام کپی های دیتا از بین بروند دیتا از دست رفته است. درواقع داریم یه سری تکنیک ها با هدف risk-reduction به کار میگیریم.

# Single-Object and Multi-Object Operations
اینجا هم باز به تکرار دو موضوع isolation و atomicity رو توضیح میده.

اگر کلاینت در قالب یه تراکنش میخواهد چندین رکورد از دیتابیس رو تغییر بده مربوط میشه به موضوع Multi-Object Operations.
شکل ۷-۲ مربوط به یک اپلیکیشن ایمیل هست. تعداد ایمیل های ناخوانده کاربر با این کوئری که در این پاراگراف هست شمرده میشه.

در این شکل کاربر ۱ یک ایمیل به کار ۲ میده. برای این کار دوتا دیتا در دیتابیس درج میشه. یکی آبجکت ایمیل که در تیبل emails اضافه میشه و دیگری ++ کردن unread counter که در تیبل mailboxes درج میشه. ولی چون اینجا خاصیت isolation نداشتیم وسط این دوتا عمل، کاربر ۲ اومد و ایمیل رو در اینباکس خودش دید در عین حال unread counter رو صفر مشاهده کرد. در واقع کاربر ۲ در این سناریو ا انومالی dirty read مواجه شد. او تونست تغییرات کاربر ۱ را بدون اینکه عملیاتش به طور کامل تمام شود مشاهده کند.


![[Pasted image 20241007133714.png]]

