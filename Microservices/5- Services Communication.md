مواردی که هنگام طراحی ارتباط بین سرویس ها باید در نظر بگیریم:
1- استفاده از روش مناسب sync یا async
2- استفاده از فرمت پیام مناسب
3- روش تعامل(مثلا یک به چنده، پیام ارسال شد ارتباط تموم میشه یا باید منتظر جواب بمونه) و تکامل api

اهمیت روش تعامل
1- تاثیر روی دسترس پذیری
2- تاثیر روی تست و صحبت سنجی
3- تاثیر روی مدیریت تراکنش و  transactiona

دسته بندی روش های تعامل
1- یک به یک 
2- یک به چند (بین یک سرویس و چند سرویس دیگر)

روش های تعامل از نظر نوع
1- روش sync
2- روش async


![[photo_5805412611905405900_y.jpg]]



توی دنیای میکروسرویس بهتره از روش api first استفاده کینم  یعنی اول api رو طراحی کنیم و توافق کنیم با کلاینت ها بعد بیایم اپلیکیشن رو توسعه بدیم. اگر اینترفیس را در میکروسرویس عوض کنیم چون هر api رو تعداد تیم ها و سرویس های زیادی دارن استفاده میکنن تغییر توش باعث میشه سرویس های دیگه تحت تاثیر قرار بگیرند.


تکامل apiها:
در طول زمان ممکنه api تغییر کنه. تعداد ورودی و خروجی و یا نوع خروجی. چون تعداد سرویس های زیادی دارن ازش استفاده میکنن نباید این حرکت ناگهانی انجام بشه. توی دنیا برای این کار از ورژن زدن استفاده میکنن (rolling update) همچنین api ها تا جای امکان باید backward compatible باشد. 

نحوه نسخه زدن معنایی:

**1.2.3-beta**

1- اگر تغییر داشته باشیم که breaking change باشه یعنی کاربران با کد قبلیشون دیگه نمیتونن از api جدید استفاده کنن (Major)
2- اگر نسخه جدید backward compatible بود. مثلا اگر پارامتری میگیریم مقدار دیفالت داشته باشه تا اگر کسی ورودی نداد بهش کار کنه. یا اگر خروجی میدیم توصیف مناسب داشته باشه تا دریافت کننده بتونه ازش استفاده کنه. (Minor)
3- رفع خطایی که backward compatible  باشه. (Patch)


فرمت پیام:
ممکنه فرمت پیام در زبان های مختلف پشتیبانی شود یا نوش. 
ممکنه روی حافظه و پرفومنس سیستم تاثیر بذاره مثلا پیام قالب خودش رو ارسال بکنه یا نکنه

پیام ممکنه متنی باشه یا باینری 

پیام های متنی
1- خوانا و قابل درک
2- سرباز زیاد در داده های ارسالی
3- سربار روی پردازش
4- خوانا و قابل درک

پیام های باینری:
ازجمله protobuffer و Avro و Thrift
هر سه روش type IDL. یعنی به یک روش خودشون پیام تعریف میشه
در این روش باید از API First استفاده کرد. 


روش Sync در RPC
یک پروکسی تعریف میکنیم که ارتباط بین سرویس ها رو مشخص میکنه. یک adapter تعریف میکنیم که توابع اون پروکسی رو پیاده سازی بکنه اینطوری مانع انتشار جزئیات ارتباطی میشیم. 
انتظار پاسخ در بازه زمان مشخص
نیاز به مدیریت صحیح خطا در فضای میکرو سرویس
نیاز به یافتن آدرس سروسی ها و یا دامنه و آی پی سرویس ها در فضای میکرو سرویس

روش های ارتباطی sync :
روش REST: 
1- استفاده از HTTP
2- قلب سیستم Resource مثلا هر Entity معمولا براش یک API داریم مثلا برای لیست کاربران یک API  دارم
3- دسترسی از طریق URL
4- نوع کار با HTTP Verb
5- معمولا داده ها متنی هست مثلا JSON


مدل **Richardson Maturity Model**
چهار مرحله داریم که اگر به مرحله 4 برسیم میتونیم بگیم Rest full داریم
0- مرحله Swamp Of Pox: سرور یک متد میده و هرجای سیستم که بخوایم دسترسی داشته باشیم از طریق این یک متد باید انجام شود. 
1- هر آدرس یک URI میدیم. یعنی میایم API ها رو گستش میدیم و برای هر Resource یک URI قرار میدیم
2- استفاده از HTTP Verb ها. دیگه داخل متد نمیگیم مثلا ذخیره کن یا آئدیت کن. با استفاده از پروتکل HTTP این کار رو میکنیم مثلا میگیم PUT کن یا POST کن 
3- استفاده از Hypermedia یعنی در پاسخ علاوه بر پاسخ یک سری Meta data قرار میدیم. مثلا اگر میگیم فلان کاربر ساخته شد یک لینک هم تو پاسخ بذاریم و نحوه دسترسی به اون رو توش مشخص کنیم. 

روش GRPC
این روش روی HTTP/2 پیاده سازی میشه
با استفاده از Protobuffer این روش رو میتونیم پیاده سازی کنیم

مشکلات و راه حل های Rest API
1- داکیومنت کردن منابع که با OpenAI انجام میدیم
2- یک resource با زیر مجموعه ها و parent و یا وابستگی هاش داشته باشیم و روشون کوئری بزنیم که این کار را با **graphQL** انجام میدیم


مزایای REST سادگی و قابل تست راحت هست. عدم وابستگی به بستر شبکه و معماری سیستم. کلا ساده و پر کاربرد هست

معایب REST
همه انواع ارتباط مثل pub/sub رو پشتیبانی نمیکنه
کاهش دسترس پذیری سیستم چون async نداره
نیاز به اطلاعات دقیق کلاینت از سرور 
عدم واکشی از چند ریسورس


مزایای GRPC
اینکه API First هست مزیته چون اول باید طراحی کنیم
بهره ولی بالا چون داده بسیا فشرده شده هست
امکان stream بودن داده
پشتیبانی از زبان های مختلف


عیب های GRPC
سمت کلاینت چالش داریم مثلا جاوا اسکریپت
همه وب سرور ها ممکنه از HTTP2 پشتیبانی نکنن


Partial failure
ریسک بالا در پیام های سینک
امکان خرابی سرویس در زمان درخواست
امکان کندی با درخواست زیاد
تجربه کاربری ضعیف خواهد بود 
منابع سیستم اشغال میشه


راه حل
یک پراکسی یا آداپتر طراحی کنیم طوری که اگر ریسپانس مناسب دستش نرسید بتونه کارش رو به درستی انجام بده
در نتیجه در طراحی API این نکات را رعایت کنیم
1- زمان انتظار محدود. بیشتر از یک حد منتظر نمونیم برای پاسخ
2- محدود کردن درخواست های در حال انتظار. اگر 1000 درخواست دادیم هنوز جواب نیومده 1001 رو ارسال نکنیم و صبر کنیم تا جواب بیاد. 
3- استفاده از الگوی circuit breaker: 
	1- جلوگیری از انتشار خطای سرویس
	2- دسترسی به سرویس با پروکسی circuit breker
	3- شمارش خطا و قطع مدار در صورت وجود مشکل. سرویس بعدی ببینه خرابه بار بیشتری روش نمیندازه
	4- چک کردن سلامتی در بازه های زمانی

پیاده سازی circuit breaker 
کتابخونه hystrix برای netflix
یا polly که opensource هست

حالا من که درخواست دادم و دیدم سرویس قطعه چطوری میتونم کار خودم رو ادامه بدم؟
1- بازگشت دادن خود خطا: یعنی به سرویس های دیگه بگیم فلان سرویس خراب بود و نتونستم اطلاعات رو بگیرم
2- مقدار پیش فرض قرار بدیم 
3- از اطلاعات کش شده استفاده کنیم
4- داده null بذاریم

هر کدوم از این راه حل ها بهتر از اینکه بذاریم خطا در کل سیستم نشر پیدا کنه

Service Registery and discovery
1- تعداد زیاد آدرس ها و داینامیک بودن آنها
2- عدم امکان استفاده از روش قدیمی در نتیجه نیاز به سرویس Service discovery

پس جایی باید باشه که آدرس سرویس ها توش ثبت بشه. مثلا دوتا instance از یک سرویس اجرا میکنیم. با اجرا شدن سرویس هر instance باید آدرس خودش رو در سرویس دیسکاوری ثبت کنه. هرکی هم بخواد از اون سرویس استفاده کنه از سرویس دیسکاوری میپرسه آدرس سرویس A رو بهم بده 

روش های پیاده سازی Service discovery 
1- پیاده سازی مستقیم در سرویس ها: خود سرویس ها مستقیما خودشون رو در service registery ثبت میکنن که به این فرآیند میگن Self Registration در این صورت باید سرویس های Heartbeat و Helth check هم پیاده سازی بشه. مثلا سرویس یک API برای Health check مینویسه تا Service registery اون رو چک کنه و اگر پایین بود بیاد اون سرویس رو حذف کنه یا یک سناریو دیگه اینکه Service registery یک API برای دریافت Heartbeat داشته باشه و هر سرویسی Heartbeat رو نفرستاد از Service registery حذف بشه 

به فرآیند خواندن اطلاعات هم میگن Clien-Side discovery 
که خود کلاینت میاد اطلاعات سرویس رو از Service registery میخونه و کش میکنه و لود بالانس میکنه 


ابزار هایی که به این صورت  مثل   Eureka و Consul هست









