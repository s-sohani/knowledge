مواردی که هنگام طراحی ارتباط بین سرویس ها باید در نظر بگیریم:
1- استفاده از روش مناسب sync یا async
2- استفاده از فرمت پیام مناسب
3- روش تعامل(مثلا یک به چنده، پیام ارسال شد ارتباط تموم میشه یا باید منتظر جواب بمونه) و تکامل api

اهمیت روش تعامل
1- تاثیر روی دسترس پذیری
2- تاثیر روی تست و صحبت سنجی
3- تاثیر روی مدیریت تراکنش و  transactiona

دسته بندی روش های تعامل
1- یک به یک 
2- یک به چند (بین یک سرویس و چند سرویس دیگر)

روش های تعامل از نظر نوع
1- روش sync
2- روش async


![[photo_5805412611905405900_y.jpg]]



توی دنیای میکروسرویس بهتره از روش api first استفاده کینم  یعنی اول api رو طراحی کنیم و توافق کنیم با کلاینت ها بعد بیایم اپلیکیشن رو توسعه بدیم. اگر اینترفیس را در میکروسرویس عوض کنیم چون هر api رو تعداد تیم ها و سرویس های زیادی دارن استفاده میکنن تغییر توش باعث میشه سرویس های دیگه تحت تاثیر قرار بگیرند.


تکامل apiها:
در طول زمان ممکنه api تغییر کنه. تعداد ورودی و خروجی و یا نوع خروجی. چون تعداد سرویس های زیادی دارن ازش استفاده میکنن نباید این حرکت ناگهانی انجام بشه. توی دنیا برای این کار از ورژن زدن استفاده میکنن (rolling update) همچنین api ها تا جای امکان باید backward compatible باشد. 

نحوه نسخه زدن معنایی:

**1.2.3-beta**

1- اگر تغییر داشته باشیم که breaking change باشه یعنی کاربران با کد قبلیشون دیگه نمیتونن از api جدید استفاده کنن (Major)
2- اگر نسخه جدید backward compatible بود. مثلا اگر پارامتری میگیریم مقدار دیفالت داشته باشه تا اگر کسی ورودی نداد بهش کار کنه. یا اگر خروجی میدیم توصیف مناسب داشته باشه تا دریافت کننده بتونه ازش استفاده کنه. (Minor)
3- رفع خطایی که backward compatible  باشه. (Patch)


فرمت پیام:
ممکنه فرمت پیام در زبان های مختلف پشتیبانی شود یا نوش. 
ممکنه روی حافظه و پرفومنس سیستم تاثیر بذاره مثلا پیام قالب خودش رو ارسال بکنه یا نکنه

پیام ممکنه متنی باشه یا باینری 

پیام های متنی
1- خوانا و قابل درک
2- سرباز زیاد در داده های ارسالی
3- سربار روی پردازش
4- خوانا و قابل درک

پیام های باینری:
ازجمله protobuffer و Avro و Thrift
هر سه روش type IDL. یعنی به یک روش خودشون پیام تعریف میشه
در این روش باید از API First استفاده کرد. 


روش Sync در RPC
یک پروکسی تعریف میکنیم که ارتباط بین سرویس ها رو مشخص میکنه. یک adapter تعریف میکنیم که توابع اون پروکسی رو پیاده سازی بکنه اینطوری مانع انتشار جزئیات ارتباطی میشیم. 
انتظار پاسخ در بازه زمان مشخص
نیاز به مدیریت صحیح خطا در فضای میکرو سرویس
نیاز به یافتن آدرس سروسی ها و یا دامنه و آی پی سرویس ها در فضای میکرو سرویس

روش های ارتباطی sync :
روش REST: 
1- استفاده از HTTP
2- قلب سیستم Resource مثلا هر Entity معمولا براش یک API داریم مثلا برای لیست کاربران یک API  دارم
3- دسترسی از طریق URL
4- نوع کار با HTTP Verb
5- معمولا داده ها متنی هست مثلا JSON


مدل **Richardson Maturity Model**
چهار مرحله داریم که اگر به مرحله 4 برسیم میتونیم بگیم Rest full داریم
0- مرحله Swamp Of Pox: سرور یک متد میده و هرجای سیستم که بخوایم دسترسی داشته باشیم از طریق این یک متد باید انجام شود. 
1- هر آدرس یک URI میدیم. یعنی میایم API ها رو گستش میدیم و برای هر Resource یک URI قرار میدیم
2- استفاده از HTTP Verb ها. دیگه داخل متد نمیگیم مثلا ذخیره کن یا آئدیت کن. با استفاده از پروتکل HTTP این کار رو میکنیم مثلا میگیم PUT کن یا POST کن 
3- استفاده از Hypermedia یعنی در پاسخ علاوه بر پاسخ یک سری Meta data قرار میدیم. مثلا اگر میگیم فلان کاربر ساخته شد یک لینک هم تو پاسخ بذاریم و نحوه دسترسی به اون رو توش مشخص کنیم. 

روش GRPC
این روش روی HTTP/2 پیاده سازی میشه
با استفاده از Protobuffer این روش رو میتونیم پیاده سازی کنیم

مشکلات و راه حل های Rest API
1- داکیومنت کردن منابع که با OpenAI انجام میدیم
2- یک resource با زیر مجموعه ها و parent و یا وابستگی هاش داشته باشیم و روشون کوئری بزنیم که این کار را با **graphQL** انجام میدیم


مزایای REST سادگی و قابل تست راحت هست. عدم وابستگی به بستر شبکه و معماری سیستم. کلا ساده و پر کاربرد هست

معایب REST
همه انواع ارتباط مثل pub/sub رو پشتیبانی نمیکنه
کاهش دسترس پذیری سیستم چون async نداره
نیاز به اطلاعات دقیق کلاینت از سرور 
عدم واکشی از چند ریسورس


مزایای GRPC
اینکه API First هست مزیته چون اول باید طراحی کنیم
بهره ولی بالا چون داده بسیا فشرده شده هست
امکان stream بودن داده
پشتیبانی از زبان های مختلف


عیب های GRPC
سمت کلاینت چالش داریم مثلا جاوا اسکریپت
همه وب سرور ها ممکنه از HTTP2 پشتیبانی نکنن


Partial failure
ریسک بالا در پیام های سینک
امکان خرابی سرویس در زمان درخواست
امکان کندی با درخواست زیاد
تجربه کاربری ضعیف خواهد بود 
منابع سیستم اشغال میشه


راه حل
یک پراکسی یا آداپتر طراحی کنیم طوری که اگر ریسپانس مناسب دستش نرسید بتونه کارش رو به درستی انجام بده
در نتیجه در طراحی API این نکات را رعایت کنیم
1- زمان انتظار محدود. بیشتر از یک حد منتظر نمونیم برای پاسخ
2- محدود کردن درخواست های در حال انتظار. اگر 1000 درخواست دادیم هنوز جواب نیومده 1001 رو ارسال نکنیم و صبر کنیم تا جواب بیاد. 
3- استفاده از الگوی circuit breaker: 
	1- جلوگیری از انتشار خطای سرویس
	2- دسترسی به سرویس با پروکسی circuit breker
	3- شمارش خطا و قطع مدار در صورت وجود مشکل. سرویس بعدی ببینه خرابه بار بیشتری روش نمیندازه
	4- چک کردن سلامتی در بازه های زمانی

پیاده سازی circuit breaker 
کتابخونه hystrix برای netflix
یا polly که opensource هست

حالا من که درخواست دادم و دیدم سرویس قطعه چطوری میتونم کار خودم رو ادامه بدم؟
1- بازگشت دادن خود خطا: یعنی به سرویس های دیگه بگیم فلان سرویس خراب بود و نتونستم اطلاعات رو بگیرم
2- مقدار پیش فرض قرار بدیم 
3- از اطلاعات کش شده استفاده کنیم
4- داده null بذاریم

هر کدوم از این راه حل ها بهتر از اینکه بذاریم خطا در کل سیستم نشر پیدا کنه

Service Registery and discovery
1- تعداد زیاد آدرس ها و داینامیک بودن آنها
2- عدم امکان استفاده از روش قدیمی در نتیجه نیاز به سرویس Service discovery

پس جایی باید باشه که آدرس سرویس ها توش ثبت بشه. مثلا دوتا instance از یک سرویس اجرا میکنیم. با اجرا شدن سرویس هر instance باید آدرس خودش رو در سرویس دیسکاوری ثبت کنه. هرکی هم بخواد از اون سرویس استفاده کنه از سرویس دیسکاوری میپرسه آدرس سرویس A رو بهم بده 

روش های پیاده سازی Service discovery 
1- پیاده سازی مستقیم در سرویس ها: خود سرویس ها مستقیما خودشون رو در service registery ثبت میکنن که به این فرآیند میگن Self Registration در این صورت باید سرویس های Heartbeat و Helth check هم پیاده سازی بشه. مثلا سرویس یک API برای Health check مینویسه تا Service registery اون رو چک کنه و اگر پایین بود بیاد اون سرویس رو حذف کنه یا یک سناریو دیگه اینکه Service registery یک API برای دریافت Heartbeat داشته باشه و هر سرویسی Heartbeat رو نفرستاد از Service registery حذف بشه 

به فرآیند خواندن اطلاعات هم میگن Clien-Side discovery 
که خود کلاینت میاد اطلاعات سرویس رو از Service registery میخونه و کش میکنه و لود بالانس میکنه 


ابزار هایی که به این صورت  کار Service Registery  و Discovery انجام میدن    Eureka و Consul هست

مزایا و معایب این روش
1- سادگی 
2- عدم وابستگی به بستر اجرا
ایرادات
1- توی هر سرویس باید این پیاده سازی و سینک شدن با این ابزارها رو پیاده سازی کنیم 
2- ممکنه پیاده سازی در یک زبان خاص سخت باشه


2- پیاده سازی توسط خود زیر ساخت 
1- وجود به صورت توکار در بستر 
2- مثلا داکر یا کوبر خودشون این مزیت Service discovery  و regisery رو دارن
3- تعیین نام و آدرس توسط زیر ساخت

بهش میگن Third-Party Registery و Server-Side Discovery 
که دیگه خودش میاد لود بالانس و اینا رو انجام میده و نهایتا یک آدرس به ما میده

مزایا و معایب این روش
1- پیاده سازی ساده و خود کار
2- عدم وابستگی به زبان و فریم ورک
عیب
1- وابستگی به بستر اجرا
2- کار از کنترل کامل توسعه دهنده خارج میشه


تا الان روش Sync صحبت شد حالا میخوایم در مورد روش Async صحبت کنیم. 
Async
تعامل کلاینت و سرور با پیام
معمولا از Message Broker استفاده میشه 
ولی میتونیم بدون بروکر هم انجامش بدیم


انواع پیام:
1- پیام Document که صرفا یک داده ای هست که به سرویس دیگه ای منتقل میکنیم
2- پیام Command که دستورسی هست که باید اجرا شه
3- پیام Event پیامی که به سرویس خاصی ارسال نمیشه و هدف اینکه به بقیه اطلاع بده یک اطلاعات و وضعیت خودش تغییر کرده

کانال ارسال پیام:
1- کانال های Point-to-point که پیام رو به یک گیرنده خاص ارسال مکینیم
2- کانال publish-subscribe که پیام ارسال میشه و هر کی به کانال دسترسی داره میتونه عضو بشه و پیام رو بخونه

این روش میتونه هم Request/response و هم pub/sub و هم on way notification رو پیاده کنیم 

مثلا برای Request/response میتونیم به ازای هر پیام یک آی دی در نظر بگیریم و سرور با توجه به آی دی پاسخ رو به کلاینت ارسال کنه

شرایط پیام رسانی:
داکیومنت کردن
فرمت ارسال و دریافت پیام
تعیین نام کانال ارتباطی

یکی از مهم ترین تصمیمات این هست که از Broker استفاده بکنیم یا نکنیم

روش Broker less Messaging
مزایا:
1- ترافیک کمتر روی بستر شبکه
2- از بین بدن که spof یعنی Single point of failure 
3- کم کردن پیچیدیگ پیاده سازی چون یک ماژول جدید داریم اضافه میکنیم و باید اون رو نگهداری هم بکنیم

معایب
1- سرویس ها آدرس هم رو باید دقیق بدونن
2- کاهش دسترس پذیری، چون Broker نیست هر دو سیستم در اون لحظه باید بالا باشن تا کار کنن یکی پایین باشه دیگه کار نمیکنه
3- تضمین اینکه پیام اینکه ارسال میکنیم به مقصد رسیده یا نه


روش Broker Base Messaging
مزایا
1- دیگه نیازی به Registery و Discovery نداریم 
2- نگهداری پیام ها در صورت وجود خطا در سرویس 
3- کاهش وابستگی بین کلاینت و سرور. یکی از سرویس ها بیاد پایین کل سیستم دچار اختلال نمیشه
ابزار های Apache kafkaو Active mq و rabbitmq
از جمله مزیتش اینکه اگر سرویس بعدی پایین باشه سرویس های دیگه تحت تاثیر قرار نمیگیرد. چون پیام تو بروکر میمونه و از بین نمیره تا سرویس بیاد بالا و پیام رو بگیره و پردازش کنه

پارامتر های انتخاب بروکر
1- پشتیبانی از زبان های برنامه نویسی مختلف
2- پشتیبانی از استانداردهای متفاوت انتقال پیام مثل AMQP
3- پشتیبانی از نوبت دهی در انتقال پیام. اینکه پیام ها به ترتیب خوانده شود یا خیر
4- تضمین انتقال و دریافت پیام
5- امکان ذخیره کردن پیام
6- نگهداری پیام در صورت نبود دریافت کننه
7- قابلیت توزیع شدگی بروکر
8- تاخیر پایین در انتقال پیام

معایب بروکر 
1- احتمالک ایجاد Bottleneck
2- ایجا یک SPOF سینگل پوینت آف فیلر
3- اضافه شدن یک بروکر به عنوان ماژول جدید یک لایه پیچیدگی رو داریم زیاد میکنیم


رقابت و نوبت دهی در میکرو سرویس و انتخاب بروکر
وقتی چند instance از یک سرویس ساخته بشه. اگر پیام هایی که از بروکر میاد به هم مرتبط باشن دچار مشکل میشیم. مثلا سه تا پیام مرتبط میاد. هر پیام میره دست یکی از instance ها. دستوری که آخر باید انجام میشد زود تر از دستوری که اول باید انجام میشد انجام میشه. اینجا دچار مشکل میشیم. پس موقع انتخاب بروکر باید به این نکته توجه کنیم که قابلیت نوبت دهی و ارسال به ترتیب رو رعایت میکنه یا نه. اگر نمیکنه خودمون باید این رو پیاده سازیش کنیم

مشکلی به نام تکرار
بروکر ها تضمین نمیکنن پیام یک بار در صف وجود داشته باشه چون این کار سربار زیادی براشون داره ولی تضمین میکنن که پیام رو حد اقل یک بار منتقل کنن. و اینکه خودمون باید این رو مدیریت کنیم که یک پیام رو هر چندبار که اومد فقط یک بار در نظرش بگیریم
روش ها:
روش Idenpotent Handler: دریافت کننده پیام رو طوری پیاده کنیم که پیام تکراری رو تشخیص دهیم یعنی اکشن تکراری تو سیستم اعمال نمیکنم. این روش بیشتر به بیزنس مربوط میشه و گاها ممکنه پیاده سازی های پیچیده ای داشته باشه. 
روش Idenpotent Consumer: پیامی که میاد رو در دیتابیس ذخیره کنیم و بعد پردازش کنیم. هر پیام جدید که اومد اول چک کنیم در دیتابیس آی دیش رو داریم یا نه اگر نداشتیم پردازش کنیم.

مدیریت تراکش
این روش سمت فرستنده باید مدیریت بشه
مثلا یک تراکنش در دیتابیس زده میشه و به ازای اون باید یک پیام در بروکر ایجاد بشه. حالا اگر پیام ایجاد نشه سیستم inConsistent میشه
برای رفع این مشکل از روش Transactionsl outbox  استفاده میشه: در این روش یک Database engin داریم که اطلاعات انتیتی ها رو توش ذحیره میکنیم. در کنارش یک جایی برای ذخیره سازی داریم که اطلاعات پیام ها هم در آن ذخیره میکنیم. حالا به جای اینکه پیام رو تو بروکر ارسال کنیم، پیام به علاوه نتیجه عملیات یا state توی اون دیتابیس به صورت Transactional ذخیره میشه به صورت موقت. حالا برای اینکه پیام رو تحویل بروکر بدیم دوتا الگو داریم. 
روش pooling publisher: یک job میذاری و در بازه های زمانی میایم پیام های جدید outbox رو میخونیم و ارسال میکنیم به بروکر
روش transaction log tailing که این روش پیاده سازی سختی داره. میگه اگر دیتابیس فایل لاگ داره بیایم از اون فایل لاگ رو بخونیم و از روی اون پیام ها رو بفرستیم تو بروکر. چون خواندن فایل لاگ دیتابیس راهکار سختیه خیلی جایی از این روش استفاده نمیکنن.





















