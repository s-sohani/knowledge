افرادی که طراحی میکردند بعد از مدتی گفتند به جای اینکه بریم دنبال entity بگردیم بیایم دنبال رخداد های سیستم بگردیم و از این طریق طراحی رو انجام بدیم چون فهمیدن تحلیل کردن و طراحی نرم افزار با بررسی رخداد ها راحت تر هست و همین شد که روش های تحلیلی مثل event storming که جلسات اولیه گفته شد به وجود آمد. 
دوتا نکته:
روش domain event وابسته به event sourcing نیست 
به صورت غیر معمول و زیادی ازش استفاده نکنید

از Domain Event دوجا استفاده میکنیم 
یکی رخداد درون دامنه هست
یکی یک پتر پیاده سازی هست

وقتی یک کاری انجام میشه و به ازای اون یک رخدادی تولید میشه. یک سری ها که براشون مهم هست روش subscribe میکنن تا مطلع شوند. همون الگوی مرسوم pub-sub. به اون هایی که sub کردن اصلاحا میگن اون رخداد و handle میکنند. این رخداد ها امکان هندل شدن داخل برنامه و هم به صورت توزیع شده خارج از برنامه رو دارن. 

نکته: ارسال و دریافت اطلاعات میتونه به صورت async باشه و یا به صورت sync انجام بشه و بسته به شرایط میشه هر کدام را استفاده کرد. 

رخدادها میتونه داخلی باشن یا خارجی باشن:
اگر رخداد داخلی هست و هندلر آن داخلی باشه دیگه لازم نیست خیلی وسواس داشته باشیم و هرچی بذاریم توش اوکیه حتی entity چون هرچی داده هاش کم و زیاد بشه به جایی وابسته نیست 
ولی اگر رخداد خارجی باشه دیگه نمیتونیم هر چیزی توش بذاریم یا هر وقت خواستیم تغییرش بدیم چون خیلی از ماژول های دیگه بهش وابسته هستند. مثلا وقتی از کافکا داریم استفاده میکنیم یک schema registery داریم تا بتونیم شمای ارتباط رو ذخیره کنیم تا کسی نتونه راحت تغییرش بده. 

توی هندلر چی کارهایی میتونیم بکنیم
میتونیم یه سیستم رو با خبر کنیم 
میتونیم فرآیند استارت کنیم 
میتونیم داخل دامنه کاری انجام بدیم و ...

جانمایی انجام شدن هندلر در اپلیکیش 
هندلر ها میتونن جاهای مختلف اپلیکیشن بشینن. مثلا میخوایم با زیرساخت کار کنیم هندلر میره تو لایه application service یا مثلا میخوایم با دامنه کار کنیم میذاریم تو لایه domain service  و ... 
ولی اغلب توی application service هست. چون با سرویس های بیرونی در ارتباط هست. 


پیاده سازی:
کنار entity یک کلاس DTO ساخت به نام event برای اون entity که فقط readonly هست از پراپرتی های اون کلاس Entity
یک اینترفیس IDomainEvent هم ایجاد کردیم و DTO ها رو گذاشتیم اون رو impl کنند تا همه event ها از یک کلاس باشن
حالا باید raiseEvent و eventDispacher ساخته بشه. کلا فرآیند هندل کردن یک رخداد دو بخش داره یکی Dispacher که تمام رخداد ها رو دریافت میکنه و میده به هندلر های مربوطه تا هندل بشه. 


تو این مثال زمان ذخیره شدن کلاس personتو دیتابیس و یا زمان تغییرش میخوایم یک رخداد raise کنیم پس توی کلاس  entity بعد اینکه person ذخیره یا بروز رسانی شد یک شی از DTO این رخداد میسازیم و توی لیست رخداد ها که از نوع IDomainEvent هست ذخیره میکنیم. البته بهتر هست این کار تو aggregation باشه که بعدا میریم سراغش 
حالا میخوایم تو Domain service بعد از اینکه به صورت async یک تغییر تو دیتابیس دادیم رخداد انجام شدنش رو بعدش بگیریم و هندل بکنیم. 

یک interface میسازیم که generic باشه و برای هندل کردن انواع رخداد انجام میشه. حالا هندلر هایی که میخوایم رو توسط این پیاده سازی میکنیم. چرا generic جون رخداد ها از اینترفیس IDomainEvent هستند. چون اینترفیس به صورت generic هست میتونیم توی مرحله بعدی 