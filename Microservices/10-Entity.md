موجودیت هایی که شناسه داره و یک طول عمری داره. به این مفهوم میگیم entity. حتی اگر همه ویژگی های دو شی یکی بود ولی شناسه های متفاوت داشت دو entity متفاوت هست.  خیلی مهمه که ما entity هامون رو پیدا کنیم و با domain expert صحبت کنیم تا مشخصات اون رو بتونیم پیدا کنیم. 

نحوه پیدا کردن entity ها:
1- صحبت با domain expert 
2- در صورت تفاوت ID متفاوت میشه
3- نیاز به ساخت شناسه ID حس میشه
4- اگر یک شی توش صحبت از طول عمر بشه. یعنی جاهای مختلف ارجاع میدیم بهش. مثلا سفارش ساخته میشه بعد اون سفارش میره تو ماژول پرداخت. بعد اون سفارش تایید میشه بعد اون سفارش ...
5- اگر instanse های متفاوت می سازیم ID هاش عوض میشه و دو موجودیت جدا میشن


پیاده سازی entity
1- تشخیص و تخصیص شناسه
2- ولیدیت کردن  entity
3- بررسی و واگذاری مسئولیت به  entity

تخصیص شناسه به  entity
یا شناسمون کلید طبیعی داره یا باید براش ایجاد کنیم. مثلا برای کانتکس ثبت احوال صحبت میکنیم یا توی کانتکس انتشارات صحبت میکنیم ISBN رو داریم. 
فقط باید حواسمون باشه که این ویژگی توی طول زمان تغییر نکنه تا توی آپدیت کردن و یا پیدا کردن اون ویژگی بعدا به مشکل نخوریم. مثلا ممکنه ISBN کتاب بعدا عوض بشه و به مشکل بخوریم یا مثلا اسم کشور ها ممکنه مثلا دوتا کشور بشن و اسماشون عوض بشه. پس کلید طبیعی رو باید خوب روش فکر کنیم و همین طوری انتخابش نکنیم

ولی زمانی که خودمون میخوایم کلید ایجاد کنیم دستمون باشه. از موارد زیر میشه استفاده کرد
1- استفاده از اعداد. توی خود کد بیایم آی دی های عددی تولید کنیم. 
2- تولید GUID مزیتش اینه که unique هست ولی عیبش اینه که حجم زیادی داره. و مثلا توی join زدن توی حجم بالا مثلا 500 تا در 500 تا حجم زیادی میشه و سیستم ممکنه نکشه
3- مقادیر چندتا ستون رو به هم بچسبونیم و یک شناسه یکتا تولید کنیم به کمک اون ها که اینم باز مشکل حجم داره
4- استفاده از ویژگی های دیتابیس. خود ORM ها میان هنگامی که داده ذخیره میکنن خودشون یک آی دی براش تولید میکنن. وقتی داده با موفقیت ذخیره شد خودش یک شناسه میده مثلا auto increment که عیبش اینه که گاهی ممکنه بخوایم قبل از ذخیره شدن داده در دیتابیس میخوایم آی دیش رو داشته باشیم. راهکاری که برای این هست اینه که میتونیم یه رنجی رو از دیتابیس بگیریم  و کش کنیم اینطوری قبل اینکه ذخیره بشه تو دیتابیس آی دی عددی رو داریم. 
5- استفاده از snowflake id که توسط توییتر معرفی شده. چندین عامل رو در نظر میگیره تا یک عدد یونیک خیلی بزرگ بسازه. ولی معلوم نیست تو لود بالا با توجه به الگوریتیمی که افراد پیاده کردن چقدر جوابه و باید تست بشه



خیلی وقت ها میگن entityها behavior rich هستند و rich domain اینطوری که entity ها behavior داشته باشن و منطق داشته باشه. 
حالا اینکه چقد باید منطق توش باشه بحث هست. 
ولی کلا مسئولیت entity مدیریت identity و شناسه هست. 
حالا اگر بخوایم قواعد بیزنس هم توش بیاریم این entity هی بزرگتر میشه و تبدیل به کد اسباگتی میشه
پس entity خودش منطق و پیاده سازی نمیکنه و بلکه نگهدارنده چند منطق کنار هم هست. مثلا منطق اصلی توی value object هست و entity این value object ها رو کنار هم نگهداری میکنه و entity صرفا ویژگی شناسه رو بهش اضافه میکنه. 
یه سری از منطق ها هم توی دامین سرویس پیاده سازی میشن



ولیدیشن در entity
خیلی مهمه که entityها self-validating داشته باشن و همیشه در state درست باشن مثلا صرفا getter  و setter نباید داشته باشن و behavior ها باید بتونن وضعیت و state رو تغییر بدن و همزمان validate هم باید بشه. نکته ای که هست اینکه entityها یک طول عمری داره و validation باید با توجه به طول عمرش انجام بشه. مثلا یک boolean در یک entity در شرایطی باید true باشه و در شرایطی باید false باشه. 
دسته دیگه invariant validation هستن یعنی پراپرتی هایی که validation آنها وابسته به زمان نیست مثلا پرواز بدون تاریخ بی معنی هست. یا مثلا هتلی که اتاق نداشته باشه بی معنی هست. 



تمرکز روی رفتار entity
علاوه بر اینکه رفتار رو از entity باید بکشیم بیرون و ببریم توی value object یا دامین سرویس. خود entity هم میتونه منطق و رفتارهای خاص خودش رو داشته باشه. مثلا یک کلاس مسابق یا match داریم که دوتا تیم میگیره. تیم 1 و تیم2. یک تابع باید داشته باشیم که getWinner رو بهمون بده. این منطق باید توی entity پیاده سازی بشه و جای دیگه نمیتونه پیاده سازی بشه. 


توزیع پذیری entity
یک entity را نباید توی همه سرویس ها داشته باشیم. اگر نیاز باشه یک entity که توی یک سرویس هست توی سرویس دیگه هم باشه کافیه از آی دی اون entity در سرویس های دیگه استفاده کنیم نه کل entity رو. در صورتی که یک entity به خوبی شکسته شده باشه این قابلیت قابل اجرا است. 


الگوهای توسعه entity
الگوی specification: به جای اینکه لاجیک توی entity ها پخش باشه یا حتی توی یک entity لاجیک های زیادی رو داشته باشیم میتونیم این لاجیک ها رو بیاریم توی یک کلاس و یک اسم بهش بدیم 

الگوی state pattern
