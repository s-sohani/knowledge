کلاس ها و اشیایی هستند که کنار entity ها قرار میگیرن و میچسبند به entity ها. با تغییر مقدار ماهیتشون عوض میشه. جایگزین premitive ها هستند. غیر قابل تغییر هستند. 
نکته، باید قابل تجمیع و combine شدن باشن
هر زمانی که داریم یک entity توسعه میدیم و اون یک property داره یعنی مفهوم بیزنسی داره از value object استفاده میکنیم. مثلا پول. میگیم هزار تومن. نکته اینکه میتونیم بیزنسش رو بیاریم کنارش. هر عددی رو نپذیره. ولیدیشن بذاریم کنارش. فایده بعدیش اینکه میتونیم مقیاسش رو بذاریم کنارش. مثلا هزار دلار یا هزار تومن

ویژگی بعدی آن این هست که شناسه ندارن. اینکه میگیم شناسه ندارن یعنی منطقا شناسه ندارن. ولی **ممکنه** برای اینکه تو دیتابیس ذخیره کنیم و بچسبونیمش بهEntity بهش شناسه بدیم ولی از نظر بیزنسی شناسه ندارن. مثلا نمیتونی بگی هزارتومنی شماره 100 علی رو بده بهم. 

میتونن سلسله مراتبی بشن و مفهوم دقیق تری نسبت به premitive type ها داشته باشن. مثلا مبلغ فروش و مبلغ خرید که هردو از نوع پول هستند

ویژگی های value object به طور دقیقتر
1- بدون شناسه
2- وابسته به مقدار
3- ارائه ویژگی
4- چسبندگی بالا
5- قابل ترکیب
6- تغییر ناپذیر
7- قابل self - validate
8- تست پذیری بالا


ویژگی بدون شناسه بودن
این value object رو توسعه میدیم برای اینکه اطلاعات یک موجودیت رو به ما بده 
مثلا 3 کیلو سیب میخریم. این 2 کیلو یک value object هست
مثلا یه یکی بگی 3 کیلو میگه 3 کیلو چی؟ پس باید بچسبونیمش به سیب 
معمولا بعد اینکه Entity ها رو کشف کردیم value object ها رو شناسایی و تعریف میکنیم

ویژگی وابسته به مقدار بودن
تساوی دو value object به شرطی هست که تمام مقادیرهای یک value object مساوی تمام attribute های value object دیگه باشن. 

ویژگی ارائه ویژگی یا behavior Rich
ما همیشه در DDD دوست دارم اجزایی داشته باشیم که این اجزا State هایی که دارن داخل خودشون hide کنن و یک سری behavior بدن به ما که اون توابع باعث تغییر State بشه. این توابع ممکنه دیتا رو تغییر نده و صرفا خواندن باشه یا مثلا یه بیزنس لاجیک رو پیاده سازی کرده باشه
مثلا یک value object برای متر داریم که یک Distance میگیره. میتونیم توش توابعی داشته باشیم که مثلا دوتا متر رو با هم مقایسه کنه. یا مثلا بگه این مقدار بزرگتر از یک مقدار متر دیگه هست یا نه
یا یه تابع دیگه داشته باشیم که مقدار رو تبدیل کنه به کیلو متر


ویژگی چسبندگی بالا
هر value object که تعریف میکنیم یه سری تابع و یک سری property داره که چسبندگیشون به هم بالاست. به عبارت دیگه خیلی بهم  منسجم هستند. پس برای value object تمام property ها باید به هم به طور منسجم یک پکیجی را ارائه کنه

ویژگی تغییر ناپذیری
هر تغییر در اون شی مصادف میشه با ساخت یک شی جدید. 
مثلا یک شی جدید ساختیم از متر. این شی رو هم به قد یک آدم میدیم مثلا علی 2 متر دارد. هم به یک ماشین میدیم مثلا میگیم ارتفاع ماشین 2 متر است. حالا اگر ارتفاع ماشین رو بخوایم بکنیم یک متر. اگر شی متر رو آپدیت کنیم و بکنیمش یک متر قد علی هم میشه یک متر و به خطا بیزنسی میخوریم. در نتیجه value object باید تغییر نا پذیر باشند و در صورتی که بخوایم تغییر بدیم یک شی جدید بسازیم 

ویژگی ترکیب 
مثلا مانده حساب رو با سود یک سالش ترکیب میکنیم و میشه یک شی جدید 
معمولا برای ویژگی های عددی صحبت میکنیم. مثلا اسم ها افراد قابل ترکیب نیست ولی ویژگی مانده حساب چون عددی هست میشه ترکیب کرد. 
خوبه این ویژگی رو راحت در اختیار کاربر بذاریم 
مثلا برای کلاس متر یک متد add بگیریم که یک شی متر میگیره و جمع میکنه با خودش و حاصل رو در قالب یک value object دیگه میده بیرون 

ویژگی self-validation
این یکی از ویژگی های rich-domain هست نه صرفا value-object برای همین اینجا هم صدق میکنه
یک مفهوم مرتبط با بیزنس داریم که هیچ موقع نمیتونه توی وضعیت غلط قرار بگیره
توی خود کلاس همه ولیدیشن ها تو کانستراکتور رو چک میکنیم.  در نتیجه خیالمون بابت تمام قواعد بیزنسی اون شی راحته. اگر یک مشکلی توی ولیدیشن باشه راحت اکسپشن ترو میکنه

ویژگی testable بودن
وقتی از value-object استفاده میکنیم یک سری قابلیت ها بهمون میده که بتونیم تست خوب داشته باشیم چرا که  value-object
1- غیر قابل تغییر هست و side-effect نداره
2- تست ایزوله و cohesion یک مفهوم رو دارن چون چسبندی بین اجزا  value-object خیلی زیاده و کمک مکنه تست بهتر بنویسیم 
3- ترکیب و تست ارتباط چند مقدار
4- تست ها با کمترین احتمال خرابی


الگوهای پرکاربرد برای پیاده سازی  value-object 
1- سادگی کد
2- خوانایی بیشتر
3- نگهداری بهتر کد


الگوی static-factory
وظیفه پنهان سازی سازنده
به طور مثال کلاس TimaStamp
اینطوری قابلیت رو میده که راحت تر یک شی از یک کلاس رو بسازیم 
مثلا کلاس  value-object رو داریم به جای اینکه مثلا برای ساخت کلاس TimeStamp به جای اینکه از ثانیه تا سال رو از کاربر بگیریم تا یک شی بسازیم مثلا میگیم TimaStamp.fromHour(1) اینطوری یک شی میسازه که همه چی مقدار دیفالت یا مقدار الان هست و فقط ساعت 1 هست. یا مثلا TimeStamp.fromSec(2) یا مثال هایی از این قبیل


الگوی Tiny Type یا Micro typ
افرادی که خیلی DDD کار میکنن گام رو یکم فراتر گذاشتن و یک  value-object روی  value-object تعریف میکنن تا وضوح کدشون بیشتر بشه 
مثلا سیستم حضور و غیاب، اضافه کار و ساعت کارکرد هر دو از نوع hour هست ولی میتونیم برای هر کدوم یک کلاس جدا بسازیم و به کلاس سوم ارسالش کنیم تا کارکرد رو محاسبه کنه. اینطوری خطا خیلی کاهش پیدا میکنه ولی تعداد کلاس ها خیلی بیشتر میشه. باید بتونیم یک تعادلی در این شرایط ایجاد بکنیم

مشکل مجموعه  value-object ها
یه سری نظریه ها میگه باید پرهیز کنی از اینکه مجموعه ای از  value-object ها در یک entity داشته باشی 
مثلا یک دفتر تلفن میخوایم داشته باشیم. یک کلاس phonebook میسازیم که توش فقط یک شماره تلفن رو قرار میدیم. بعد یک کلاس person میسازیم که توش اسم و فامیل و لیستی از شماره تلفن ها رو میگیره. حالا اگر بخوایم بگیم شماره تلفن خونه فلان فرد رو بهم بده دچار مشکل میشیم چون لیست شماره تلفن گرفتیم برای یک فرد و نمیدونیم کدوم برای خونه هست یا کدوم برای کار. اگر بخوایم این مشکل رو حل کنیم مجبوریم که یک شناسه یا یک تایپ به کلاس phoneNumber اضافه کنیم که با این کار یک identity به کلاسمون اضافه کردیم. راه بهتر این هست که به جای اینکه لیست بگیریم بیایم هر کدوم از type ها رو یک شی بگیریم مثلا یک شی از phoneNumber درست کنیم برای محل کار یا یکی درست کنیم برای منزل و ... و اینطوری مشکل مجموعه  value-objectها رو رفع کنیم 

بحث ذخیره و بازیابی  value-objectها
این مورد برمیگرده به ابزارها و سیاست هایی که انتخاب میکنیم. مثلا از noSql ها استفاده کنیم دغدغه ای نداریم. اما اگر sql داشته باشیم یکم مساله میشه چون دیگه nested نمیتونیم آبجکت ها رو ذخیره کنیم 
مثلا یک  value-object داریم یا لیستی از  value-objectها داریم. یا  value-object ای که داریم تک property هست یا چند property داره 
اگر مثلا یک  value-object در یک کلاس مثلا person داشته باشیم که خودش شامل نام و نام خانوادگی باشه توی فرآیند تبدیل به جداول دیتابیس میتونیم flat کنیمش و نام و نام خانوادگی رو از دل کلاس بیاریم بیرون و کنار پراپرتی های دیگه جدول ذخیرش کنیم 
ولی گاهی شرایط پیچیده میشه و نیاز هست برای  value-object ها هم id در نظر بگیریم تا بتونیم پیداش کنیم و به entity وصلش کنیم در این شرایط چطوری باید بحث تبدیل کردن  value-objectها رو انجام بدیم؟
قدیم  value-objectها رو به entity تبدیل میکردیم و بهش id میدادیم و سختی های این کار و به جون میخریدیم ولی EF core نسخه جدید قابلیتی داده که این کار رو ساده کرده. که اون استفاده از owned type هست. یک ویژگی دیگه آن value conversion هست که EF داده و میتونیم از اون استفاده کنیم. 

نوشتن کلاس پایه Base class برای  value-object
