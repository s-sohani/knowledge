کتاب The Art Of Scalability
سه محور برای اسکیل داریم. محور های x,y,z

محور X:
تک اپلیکیشن داریم. چند کپی از اپلیکیشن اجرا میکنیم و یک لودبالانسر میذاریم سرش. 
مزایا:
ساده
مدیریت ساده تراکنش ها
سرعت بالای پیاده سازی
معایب:
هزینه سخت افزاری بالا 
مشکلات کش و session و ...
عدم تناسب با ساختار سازمانی 

محور Z:
به جای لود بالانسر یک روتر میذاریم و با توجه به دیتایی که میاد درخواست را میفرسته به یکی از اپلیکیشن ها. هر اپلیکیشن هم بخشی از دیتا رو نگه میداره. بیشتر این حرکت رو دیتابیس ها میزنن و با توجه به کلید شارد این روتینگ انجام میشه. یا مثلا سرور داریم نقاط مختلف کشور با توجه به کد ملی افراد درخواست میره سمت یکی از شهر ها تا لود پخش بشه .
مزایا:
سرعت پاسخ زیاد میشه
اگر بخشی از مدار خارج بشه سیستم کلی به مشکل نمیخوره
معایب:
شارد کردن داده سخته
ساختار سازمانی در نظر نگرفته شده
فرآیند های اتوماتیک زیادی رو باید براش در نظر بگیریم

با این دوتا scalability و availability رعایت شده ولی هنوز پروژه مونولیک هست. همچنین فرآیند توسعه کنده هنوز

محور Y:
خورد کردن سیستم بر اساس functionality که هر اپلیکیشن یک کار کامل از صفر تا صد انجام میدن و هر کدوم دیتابیس خودشون رو دارن و بیزنس فیچر های اختصاصی خودشون رو دارن و با API با اپلیکیشن های دیگه در ارتباط هستن. 

مثل راه حل ماژولار:
تقسیم و غلبه راه حل مشکلات بزرگ 
هر سرویس یک ماژول
انتشار عملکرد با API
جلوگیری از دسترسی غیر مجاز


مزایا و معایب این روش:
قابل scalability هر سرویس جداگانه. با منابع محدود و اندازه همون سرویس و به صورت بهینه
تیم های خودمختار. وابسته به تیم های دیگه نیست و با کمترین تعامل میتونیم کار رو پیش ببریم. تا الان سه تا api داشتیم از الان ۴ میشه. 
سادگی در مهاجرت تکنولوژی. مثلا الان با جاوا بود راحت میبریم روی پایتون یا مثال های دیگه
عدم انتشار خطا. مثلا اگر یک سرویس مموری لینک داشته باشه به سرویس های دیگه آسیب نمیزنه و بقیه سرویس ها کار میکنن و مثل مونولیتیک نمیشه که کل سیستم بیاد پایین. 
ایجاد امکان ci/cd
اندازه کوچک و نگهداری ساده. درک کل سرویس خیلی سریع و راحت انجام میشه
کامل و تنهای قابل انتشار


معایب این روش:
تعیین محدوده مشکل. جدا سازی محدوده بین هر سرویس. که این کار بیشتر از روی تجربه هست. سرویس ها رو بشکونیم یا مرج کنیم دائم
تست و انتشار پیچیدگی. تست کردن صفر تا صد پروژه سخت انجام میشه و باید تست به همراه تعامل بین سرویس ها انجام بشه. هر api باید backward compatibleباشه. 
توزیع ویژگی های مشترک بین چند سرویس. هر بخش از دیتا بین چند سرویس مختلف هست و برای یک کار با چندین سرویس باید کار کنید.
تشخیص زمان مناسب برای انتخاب. شروع کار با مونولیک هست و از جای دیگه باید پروژه رو بشکونیم و به میکروسرویس مهاجرت کنیم. زمان مناسب برای این کار چه زمانی هست؟
توسعه و نگهداری پیچیده. پروژه توسعه داده شده برای توسعه مونولیک و برای میکرو سرویس آماده نشدن. تنوع ابزارها زیاد میشه. 


روش ها و الگوها
پیچیدگی در لایه های مختلف
نیازمند راه حل برای هر مشکل
پیچیدگی های زمان توسعه
پیچیدگی های زیر ساختی و توسعه
پیچیدگی های زیر ساختی

صورت مسآله هایی که قراره براش راه حل بگیم شامل:
![[Pasted image 20240412125201.png]]


![[IMG_8280.jpg]]


شکاندن تیم به تیم های کوچیک. البته این کار باعث میشه روابط بین آدم ها پیچیده تر میشه و باید ساختار تیم رو طوری بچینیم تا این به مشکل نخوره. 
زیرساخت باید داشته باشیم 
فرآیند های CI/CD و DevOps خوب تا این همه سرویس رو راحت بتونیم دیپلوی کنیم
متودولوژی اجایل و تغییر زیاد باید داشته باشیم. سازمان باید آماده تغییر سریع باشن. مثلا نمیشه با سازمانی که دیدگاه water fall داره بریم سراغ میکرو سرویس.
توجه کرن به احساس آدم ها، شکوندن آدم ها به تیم های کوچک باعث میشه افراد از دوستانشون جدا بشن و از محدوده امنشون خارج بشن پس باید این کار کم کم انجام بشه تا مقاومت نکنن. 