هر Entity علاوه بر اینکه یک سری پراپرتی و رفتار داره ارتباط با اشیا دیگه هم دارند مثل value object  و یا رابطه با entity های دیگه. مثل ارتباط مشتری با سفارش یا ارتباطش با اجزا سفارش. اینکه ارتباط یک طرفه باشه یا دوطرفه باشه یا اندازه ارتباط چقدر باشه مهمه چون اینا طول عمر یکسانی باید داشته باشن و با هم ساخته شوند و با هم پاک شوند. 


برنامه نویس های سنتی اولش که بخوان اپلیکیشن رو پیاده سازی کنند اول میرن دنبال اجزا اطلاعاتی که اصطلاحا میگن اپلیکیشن data sentric ولی ما میخوایم اپلیکیشن هایی توسعه بدیم که domain sentric هستند یعنی به جای تمرکز روی داده ها روی رفتار ها تمرکز میکنیم و میایم رفتار ها رو در قالب entity پیاده سازی میکنیم که هر کدوم از موجودیت ها خودشون یک سری value object دارند. 
ولی وقتی داریم entity ها رو پیاده سازی میکنیم یک سری از رفتار ها وابسته به نوع ارتباطی هست که entity ها با هم دیگه دارند. تو این سطح نباید به رابطه دیتابیسی فکر کرد چون ممکنه دیتابیس document base باشه و ریلیشن نداشته باشه. اینجا منظور رابطه اشیا با هم هست. 

این ارتباط ها میتونن پیچیدگی اپلیکیشن رو کم یا زیاد کنند. مثلا یکی از اجزا ماشین به تنهایی درست کار میکنه ولی مهم این هست در کنار اجزا دیگه هم درست کار کنه. 

پیاده سازی entity ها از طریق دنیای واقعی پیچیده هست و گاها پیاده سازی رابطه ها باعث میشه یک loop ایجاد بشه. 

پس علاوه بر اینکه به entity ها و رفتارهاشون ارائه میدن باید توجه کنیم به نوع و تعداد و جهت و نحوه برقراری ارتباطات هم باید توجه کنیم. 

مثلا اگر ارتباط لیست Orderline ها رو در کلاس Order داشته باشیم میتونیم مجموع سفارشات رو محاسبه کنیم ولی اگر نداشته باشیمش نمیتونیم این جمع رو انجام بدیم. 

پس ارتباط درست باعث میشه یک سری رفتار رو بتونیم داشته باشیم. 
توی این ارتباط ها لازم هست که یک entity با ارتباط هاش به صورت transactional با هم ذخیره بشن و با هم واکشی بشن تا اطلاعاتمون consistence باشن. که کار خیلی سختی هست چون ممکنه فضا concurrent یا parallel باشه و باعث بشه تراکنش fail بشه (چون یکی زودتر اومده یک رکوردی که دست تو بوده رو تغییر داده) و تمام کارهایی که کاربر در یک thread انجام داده از دست بره و دوباره باید انجام بشه.

تو این سطح دیتابیس رو باید بریزیم دور و باید به بیزنس رول ها توجه کنیم تا بتونیم گراف کوچیکی از روابط بسازیم. 

پس اگریگیت میاد یک سری اشیا رو کنار هم میذاره و یک گراف کوچیک میسازه تا پیاده سازی بیزنس رول ها راحت تر بشه. مثلا bounded context ها که اپلیکیشن رو میشکوند به اجزاء کوچیک aggregate هم میاد همین کار رو میکنه و هر context رو میشکونه به یک سری گراف کوچیک 


ما وقتی یک اپلیکیشن رو پیاده سازی میکنیم دوتا فضا دایم یکی فضای دامنه و یکی فضای دیتا. ما کلا روی فضای دامنه تمرکز میکنیم domain model رو میسازیم و Data model رو میسپاریم به ORMها. مثلا یک کلاسی که داریم برای ما دیگه اهمیتی نداره که foreign key داره یا نداره این رو ORM میاد هندل میکنه. 

خیلی از افرادی که تازه کار هستند سعی میکنن پراپرتی و رفتار رو استخراج کنن و پیاده کنند و به ارتباطات توجهی ندارند یا ارتباط های ضعیف میسازن. اینجا ما میخوایم بدونیم وقتی یک گراف آبجکت داریم چطوری میتونیم کوچیک و با ارتباط های قوی ایجاد کنیم. 


ارتباط یک طرفه:
در دنیای واقعی کلی روابط دو طرفه وجود داره. ولی در دنیای برنامه نویسی باید از این فرار کنیم و روابط رو یک طرفه کنیم. اگر data model رو نگاه کنیم ارتباط ها دو طرفه میشن اکثرا ولی اگر به صورت domain model نگاه کنیم باید سعی کنیم روابط رو یک طرفه کنیم. 
پس اولین گام این هست که روابط دو طرفه رو حذف کنیم.  مثلا یک کلاس product داریم و یک کلاس discount داریم لازم نیست هر دو یک شی از هم توشون داشته باشن. بسته به اینکه چه رفتاری میخوام پیاده کنیم یکیش کافیه

گاهی میبینیم برای ایجاد ارتباط در پایگاه داده یا نمایش در UI میایم روابط جدید ایجاد میکنیم. مراقب باشیم برای اینطور نیازمندیها هیچ موقع رابطه در domain model ایجاد نکنیم و فقط یک زمانی که بیزنس رول میخواد این رابطه رو ایجاد کنیم. 
باید همش از خودمون سوال کنیم با گذاشتن یا نذاشتن این رابطه کدام رول رو میتونیم پیاده کنیم یا کدام رول رو نمیتونیم پیاده کنیم. 

داشتن ارجاع و رابطه برای مدل دامنه ضروریه ولی باید کنترلش کنیم. مثلا رابطه یک به چند که روز به روز داره بزرگ تر میشه به جایی میرسه که مثلا یک فرد هزاران پرداخت اعتباری خواهد داشت اگر بیایم همه هزارتا رابطه رو از پایگاه داده واکشی کنیم به مشکل مبخوریم. پس باید این رابطه رو کنترل هم بکنیم مثلا بگیم تو فلان بازه بیا این واکشی ارتباط رو انجام بده. به این صورت تعداد رکوردهایی که در این رابطه هست کمتر هم خواهد شد. 

خیلی وقت ها به بخشی از اطلاعات یا حتی فقط به آی دی شی دیگه در رابطه نیاز داریم. پس فقط همون آی دی یا همون بخش از دیتا رو در نظر میگیریم به جای اینکه کل آبجکت رو در رابطه بذاریم. 

الگو Aggregate
1- رعایت قواعد توصیف شده در ساده سازی (یک طرفه بودم، پیاده سازی بخشی از entity، کنترل کردن رابطه)
2- نیاز به دسته بندی صحیح اشیا و پیاده نکردن رابطه های اضافی و خارج از domain model
3- ایجاد یک محدوده مناسب جهت consistency یعنی در یک aggregate در یک برشی از زمان تمام داده ها آخرین وضعیت خودشون هستن و با هم consistence هستند. حالا بیرون حوزه aggregate برامون مهم نیست که consistence باشن یا نه یا در شرایطی یه سری از دیتا عوض بشن. ولی وقتی وارد مرز یک aggregate میشیم دیتا در اون برش زمانی consistence هستند. 
مثلا order و orderline وقتی وارد aggregate میشیم با هم از دیتابیس واکشی میشن و با هم در دیتابیس ذخیره میشن تا وقتی از aggregate خارج بشیم. 

طراحی حول Invariant (قواعد)
مثلا بدست آوردن تعداد order ها یک قاعده و رول نیست و فقط گزارش دهی هست پس میتونیم خودش و رابطش رو حذف کنیم. 


یک سری قواعد هست که خارج از حوزه entity هست و باید حول aggregate این رفتار و قواعد پیاده سازی بشه. پس یک کلاس aggregate root باید داشته باشیم تا این قواعد رو توش پیاده سازی کنیم. معمولا یکی از Entityهای داخل یک aggregate به عنوان AggregateRoot انتخاب میشه اونی که owner اون aggregate هست و انتزاع بالاتری نسبت به بقیه داره
ذخیره و بازیابی از aggregateRoot انجام میشه
دادن api های public در aggregate root هست
مدیریت consistency هم توی aggregate root هست 


موقع خواندن و نمایش توی UI یا تهییه گزارش ممکنه چند aggregate رو بخونیم حتی با هم ترکیبش کنیم ولی موقع نوشتن فقط یک Aggregate رو به صورت transacional مینویسیم تو پایگاه داده
 
همانطور که گفته شد داخل aggregate باید immediate consistency داشته باشیم یعنی وقتی ذخیره میکنیم در لحظه همه دیتا باید آپدیت بشن ولی خارج  aggregate میتونیم eventual consistency داشته باشیم یعنی وقتی یک  aggregate ثبت شد یک event بده تا بقیه  aggregate ها بعد چند ثانیه یک یک یا چند روز بسته به بیزنس بروز رسانی بشن. ممکنه یه سری  aggregateها رو بذاریم شب ها انجام بشه کارشون یا یک سری بعد چند ثانیه انجام بشه. مثلا یک جنس رو میفروشیم بعد چند ثانیه موجودی انبار رو کم کنیم اوکی هست ولی در حد روز نمیشه یا مثال دیگه مثلا اگر کسی از فروشگاه خرید میکنه این اوکی هست که آخر روز بیایم امتیاز هاش رو محاسبه کنیم و بروز کنیم 
جدا کنه eventual و immediate هم برای این هست که گراف های کوچیک  aggregate داشته باشیم. بیزنس ها دوست دارن همیشه immediate consistence باشن ولی چاره نیست و باید باهاشون صحبت کنیم و راضیشون کنیم تاخیر چند ثانیه رو بپذیرند تا بتونیم پیاده سازی بهتری داشته باشیم. 

ممکنه برای انجام کاری چند  aggregate رو بخونیم و نهایتا یک  aggregate ذخیره کنیم این ایراد نداره ولی اگر همه  aggregate ها با هم ذخیره بشن به مشکل میخوریم . این هم فقط برای Delete  و Update هست. add کردن چند  aggregate مشکلی نداره بازم. 


یک معیار دیگه برای  aggregate کوچک بودن  aggregate هست. یک  aggregate نباید خیلی بزرگ بشه تا جایی که میشه باید کوچیک باشه. 
یک معیار دیگه این هست که بتونیم variant ها و رول ها رو راحت توش پیاده کنیم. اگر نیازه به consistency بین دوتا entity نداریم لزومی نداره داخل یک  aggregate بیان یا اگر نیاز صرفا نیاز به یک شناسه از یک entity دیگه داریم پس نیاید اینا داخل یک  aggregate بیان صرفا اون شناسه رو بهش پاس میدیم خارج از  aggregate. 

مثلا خبر و نظرات خبر درسته که دیتابیستی با هم رابطه دارن ولی توی یک aggregate قرار نمیگیرن
ولی مثلا سامانه پرسش و پاسخ رو در نظر بگیریم و بگیم پرسشی پابلیش میشه که حتما یک جواب تایید شده داشته باشه. در این شرایط چون پرسش و پاسخ یک rule مرتبط به هم دارن پس توی یک  aggregate قرار میگیرند. چون نیاز به اطلاعات هم دارن تا بتونن یک invairant رو پیاده کنن

همانطور که گفته شد UI و دیتابیس اصلا برامون مهم نیست و فقط نوشتن هست که در  aggregate مهمه. برای خوندن کلا میتونیم مستقیم به دیتابیس وصل شیم یا data model دیگه داشته باشیم یا مثلا دیتابیس مهم نیست که بین دوتا entity رابطه هست یا نیست. مهم برای ما پیاده سازی buisiness rule ها هست. 

نکته دیگه اینکه بروز رسانی  aggregate یک فرآیند دائمی هست. مثلا بعد دوسال یک رول جدید میخوایم اضافه کنیم ممکنه  aggregate هامون عوض بشه تا بتونیم اون رول رو اضافه کنیم و کد رو refactor کنیم.  پس دنبال این نباشیم که از روز اول یک  aggregate کامل و درست داشته باشیم. ممکنه پرفومنس بد هست نیاز هست  aggregate رو عوض کنیم یا هزارتا دلیل دیگه. 

پس  aggregate مرز بندی entity هست. هر اگریگیت هم یک repository داره برای ذخیره کردن. پس هر موقع بخوایم  aggregate رو بروز کنیم همه این ها رو باید تغییر بدیم.

نکات پیاده سازی:
همان طور که گفتیم یکی از entity ها که دروازه  aggregate هست رو باید انتخاب کنیم و بهش بگیم aggregate root . مسئولیت مدیریت entity ها و اینکه چه زمانی یک Event باید ایجاد بشه بر عهده  aggregate root هست. پس یک entity رو انتخاب میکنیم و به جای اینکه از کلاس entity ارث بری کنه از کلاس aggregate root ارث بری میکنه

ارجاع داشتن چند aggregate به هم 
فقط میتونیم از جنس شناسه پاس بدیم بین  aggregateها و شی نباید جابه جا کنیم. اون هم فقط شناسه aggregate root. بقیه شناسه های entity های داخل  aggregate نباید id بیاد بیرون و بره توی یک  aggregate دیگه

ذخیره و بازیابی توسط repository ها انجام میشه. برای هر  aggregate یک repository داریم. یک بار دیگه این نکته رو باید بگیم که فقط توی command query این صادق هست و توی query و گزارش گیری های اپلیکیشن سرویس نباید از این استفاده کنیم. 
برای حذف هم یک  aggregate رو که داریم کل entity های اون  aggregate باید حذف بشه. 

خلاصه بخش consistency
مدیریت eventual consistency رو میسپاریم به domain event و immediate consistency رو میسپاریم دست ORM ها. 

خلاصه بحث event توی بخش eventual consistency
ما دو دسته event داریم. اونهایی که داخل bounded context  میرن و آن دسته که خارج bounded context میرن. 
اون eventهایی که خارج کانتکت برن میذاریمش توی out box و بعد میذاریمش توی message bus و از اون طریق دریافت میکنیم.  
اون eventهایی که داخل هست که برای اون یک dispatcher گذاشتیم که بعد اینکه گذاشتیم توی out box تحویل dispatcher داده میشه تا پردازش شود. 
حالا اگر event ای که داخل یک کانتکس زدیم fail بشه چی میشه؟ تراکنش من پردازش شده و event درست میشه اون طرف 5 تا handler داره که 2 تاش درست میگیره و 3 تاش نمیگیره. اینطوری سیستم میره تو حالت غیر صحیح که در این صورت پیدا کردنش سخت میشه حالا باید چطور جلوش رو بگیریم؟
توی اپلیکیشن های توزیع شده فرآیندهایی دیدیم که جلوی این مورد رو بگیره مثلا بحث transactional outbox رو دیدم تا مطمئن بشیم event و Entity با هم ذخیره میشن و با هم خارج میشن از اپلیکیشن جاری از اون طرف event publisher داریم که eventها رو یک بار توی صف ثبت میکنه. از اون طرف بحث identpotent consumer رو داریم که یک event رو بگیره و به درستی پردازش کنه و اگر نشد دوباره بگیره و پردازش کنه. 
حالا توی یک کانتکس همین شرایط رو داریم که راهکارش همین روش هایی هست که در سیستم توزیع شده استفاده میکنیم. یعنی به جای اینکه event داخلی داشته باشیم همه eventها رو خارجی بگیریم و همه event ها رو در یک بروکر بزنیم و از اون بخونیم و پردازشش کنیم.  البته به شرط اینکه تاخیر چند ثانیه ای مشکلی برای بیزنس ایجاد نکنه. 


ذخیره و بازیابی به دو روش انجام میشه یا به صورت Repository یا به صورت event sourcing  که در جلسات بعدی صحبت میکنیم. 

