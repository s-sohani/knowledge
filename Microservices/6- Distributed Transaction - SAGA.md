در محیط های مونولیتیک مدیریت تراکنش توسط دیتابیس مدیریت میشه ولی در محیط های توزیع شده خودمون باید این رو انجام بدیم که چالش هایی داره 

اعمالی که یا همشون باید انجام شود یا اگر یکیش fail شد همه باید Fail شوند. 
وقتی یکی از سرویس ها یکی از کار ها رو نتونست انجام بده کل فرآیند باید fail شود. 

یکی از روش ها که ساده هست ولی معایب زیادی داره Distributed transaction هست 
یکی دیگه از روش ها جهت رسیدن به ACD الگوی SAGA هست که فقط I یا Isolation رو نداره که باید برای این هم راه کار داشته باشیم 

روش Distributed Transation
در این روش میایم از کامیت دو مرحله ای استفاده میکنیم به این صورت که یک آی دی برای تراکنش در نظر میگیریم. تراکنش هایی که هر سرویس باید انجام بده از طرف Transaction Manager ارسال میشه. بعد از اینکه هر سرویس کار مربوط به خودش رو انجام داد نتیجه رو به Transaction Manager اطلاع میده. اگر همه سرویس ها خبر موفقیت آمیز بودن رو ارسال کنن به Transaction Manger حالا Transactin Manager به همشون میگه برید کامیت نهایی این آی دی رو انجام بدین. حالا اگر یکی هم خطا انجام بده مدیر تراکنش به همه میگه رول بک کنید. 

معایب این روش:
بسیاری از دیتابیس ها و صف ها مثل کافکا و اینا این قابلیت رو پشتیبانی نمیکنن
دسترس پذیری میاد پایین چون ممکنه در لحظه یکی از سرویس ها پایین باشن. در این صورت سیستم نمیتونه کار کنه. این نکته با تئوری CAP هم همخوانی داره چون میخواد C رو داشته باشه (در هر لحظه بروز ترین نسخه داده) ولی A رو کم میکنه. در صورتی که همه سیستم ها A براشون مهم تر هست و میگن حالا آخرین نسخه داده رو با یک روز تاخیر هم دادی اشکال نداره. که این روش A رو نداره. 


روش SAGA
اگر فرآیند قراره در چند سرویس مختلف انجام بشه بیاید اون فرآیند رو در قالب تراکنش لوکال انجام بدیم. مثلا یک سرویس یک تراکنش لوکال انجام میده نتیجه رو میده به سرویس بعدی. مثلا یکی میاد یه کالایی رو سفارش میده. سرویس ثبت سفارش اون سفارش رو حالت Pending میکنه. میره دست سرویس انبار. انبار چک میکنه کالا رو داره. پس اون کالا رو قفل میکنه تا کس دیگه نتونه بیاد بگیرتش پس اون هم میره حالت Pending بعد میره سرویس حمل و نقل. میبینه طرف در محدوده هست ولی براش ارسال ثبت نمیکنه و اون هم حالت Pending میمونه بعد میره سرویس پرداخت. پرداخت که با موفقیت انجام شد دوباره برمیگرده از اول همه سرویس هایی که در حالت Pending بودن به مرحله انجام شده وضعیت رو تغییر میدن. 
همه پیام ها به طور Async توسط بروکر انجام میشه. در نتیجه A میره بالا. 
همون طور که گفتیم ایزولیشن رو نداریم در این روش. مثلا اگر همزمان یک یک نفر داره سفارشش بررسی میشه یکی دیگه بیاد بپرسه کالا رو دارین یا نه ما میگیم نداریم در صورتی که اون سفارش هنوز تایید نهایی نشده و ما اون کالا رو داریم ولی میگیم نداریم. پس دو تراکنش تاثیر مخرب رو هم میذارن .

در هر کدوم از این سرویس ها ممکنه fail داشته باشیم. در این صورت باید ماکنیستمی داشته باشیم که اگر یک fail انجام شد به همه سرویس ها اطلاع بدیم که rollback کنند. 

نکته ای که هست اینکه سرویس ها به ترتیب که حالت Pending قرار میگیرند به ترتیب برعکس باید از این حالت در بیان مثلا وقتی ما میریم سفر اول هتل رو رزرو میکنیم بعد ماشین رو رزرو میکنیم بعد هواپیما میگیریم حالا اگر هواپیما جا نداد اول میایم ماشین رو لغو میکنیم بعد هتل رو لغو میکنیم. در نتیجه به صورت معکوس میایم این فرآیند ها رو لغو میکنیم


تراکنش compensatable
تراکنش هایی که نیاز به فرآیند اصلاحی دارند. مثلا وقتی سفارش میره حالت Pending باید فرآیند اصلاحی داشته باشیم که از این حالت درش بیاریم

یک سری تراکنش های هست که read only هست و نیاز به فرآیند اصلاحی نداره مثلا فلان کالا رو موجود داریم یا نه دیگه نیاز به فرآیند اصلاحی نداره 


تراکنش های retriable
در یک فرآیند ممکنه به مرحله ای برسیم که بعد اون مطمئن هستیم که دیگه فرآیند fail نمیشه. مثلا تو سیستم فروشگاهی وقتی مرحله پرداخت رو رد میکنیم دیگه مطمئن هستیم دیگه تراکنش کنسل نمیشه و میتونه تا آخرش ادامه پیدا کنه. مثلا کسی که پرداخت رو انجام داد لاجرم باید اون کالا براش تخصیص داده بشه و از انبار در بیاد و براش ارسال بشه. در نتیجه دیگه اصلا نباید fail بشه و باید تا اخرش بره. اگر یک سرویس به خطا بخوره باید اینقد retry کنیم تا با موفقیت به پایان برسند. 

تراکنش های Pivotal
آخرین تراکنشی که قابلیت خراب کردن کار رو داره و اگر ازش عبور کنیم دیگه یا تراکنش retriable داریم یا تراکنش Read only بهش میگیم تراکنش Pivotal 



در فرآیند SAGA چه کسی مسئول نظم و ترتیب دادن به این فرآیند هست؟
برای پیاده سازی این Coordination دو روش داریم 
1- روش Choreography: اگر مسئولیت هماهنگی را بین سرویس ها تقسیم کنیم. منطق و ترتیب توالی اجرا شدن هم بین سرویس ها تقسیم میشن
2- روش Orchestration: یک هماهنگ کننده مرکزی داشته باشیم و اون هست که به هر کدوم از میکروسرویس ها میگه چه کار کنن. و تو هر مرحله هر سرویس نتیجه کارش رو به هماهنگ کننده مرکزی اعلام میکنه و اون هست که تصمیم میگنه سرویس بعدی چیه و باید چه کاری انجام بشه


روش choreography 
این روش ساده ای هست. فرآیند از یک جای سیستم شروع میشه و سرویس ها با نظر از پیش تعیین شده میره جلو. و هر سرویس با ارسال event نتیجه رو به سرویس بعدی ارسای میکنند. 
نکات این روش:
1- باید حواسمون باشه اطلاعات به درستی در دیتابیس ذخیره میشه
2- باید مطمئن باشین event به درستی ارسال شده. مثلا اینطوری نباشه که دیتا رو ذخیره کردیم ولی Event ارسال نشه. جلسات پیش برای اطمینان از ارسال رخداد روش هایی گفته شد. 

مزایا
1- سادگی این روش در پیاده سازی
2- عدم وابستگی سرویس ها به هم
معایب
1- پیچیدگی مراحل. مثلا یک جا مشکل خورد باید همه سرویس ها رو به ترتیب بریم جلو ببینیم مشکل کجا بوده
2- وابستگی متقابل بین سرویس ها. یک سرویس ممکنه یکی دوبار رفت و برگشتی بین هم داشته باشن. 
3- همه سرویس ها باید بدونن از کدوم سرویس چه رخداد هایی رو باید بگیرن و چی رو نباید بگیرین که این ممکنه وابستگی سرویس ها به هم رو زیاد کنه. 



روش Orchestration
یک بخش هماهنگ کننده مرکزی داریم. یک سری درخواست و پاسخ به صورت async پیاده سازی میکنیم. به صورت state machine باید بریم جلو. درخواست رو هماهنگ کننده مرکزی میزنه به یک سرویس. پاسخ را دریافت میکنه و با توجه به State ای که داره تصمیم میگیره وضعیت بعدی چه خواهد بود. 
به نظر میاد این روش پیاده سازی تمیز تری داره و پیشنهاد میشه برای SAGA از این روش استفاده شود. 
مزایا:
1- سادگی در فرآیند و وابستگی بین سرویس ها
2- عدم وابستگی متقابل
3- پیاده سازی seperation of concern هم بهتر پیاده سازی میشه چون هر سرویس فقط لاجیک خودشون رو پیاده سازی میکنه و کاری نداه پیام از کجا میاد و به کجا میره 
معایب
1- وابستگی شدید به هماهنگ کننده مرکزی. اگر هماهنگ کننده مرکزی به مشکل بخوره همه به مشکل میخورن و spof داریم
2- تمایل به هوشمند کردن هماهنگ کننده مرکزی. مثلا یه سری لاجیک هم اضافه کنیم به هماهنگ کننده مرکزی که باعث نشر لاجیک میشه. لاجیک نباید توش بیاریم 



راه حل isolation
یعنی کارهای همزمان  در نتیجه نهایی کارها اثر نذاره. یا کار ها رو به ترتیب جا به جا انجام بدیم نتیجه نهایی عوض نشه.  در این صورت که اطلاعات درست ذخیره نشه به علت وجود نبودن isolation بهش میگن anomaly
مثلا ساگا یه سری state رو عوض کرده، شرایطی پیش میاد که مجبوریم اطلاعات رو rollback کنیم، ممکنه شرایطی پیش بیاد که ساگا نتونه اطلاعات رو rollback کنه مثلا من یه عدد رو از 2 کردم 3 حالا یه سرویس دیگه میاد از 3 میکنه 4. حالا من باید چه کنم بیام برگردونم رو 2 یا روی 3. اینم باز یک annomaly هست که باید براش فکر کرد. 


خیلی وقت ها میتونیم سطح ایزوله بودن رو بالا یا پایین کنیم مثلا پرفورمنس رو کم کنیم و پرفورمنس رو بالا ببریم یا برعکس. یعنی با این پارامتر هم میشه بازی کرد. 


آشنایی با آنومالی
به سه دسته تقسیم میشه
1- دسته loos update: فرآیندی که یک ساگا میاد اطلاعات یک ساگای دیگه رو تغییر میده بدون اینکه اون اطلاعات رو بخونه و سیستم رو در وضع غلط قرار میده. مثلا یک مشتری یک سفارش رو ثبت میکنه و در وضع در انتطار پرداخت قرار میده. بعد میرسه به مرحله پرداخت و اونجا به هر دلیلی کارش طول میکشه. بعد مثلا پرداخت میکنه و داره صبر میکنه تا پرداختش تایید بشه. تو این وضعیت پشیمون میشه و میخواد اطلاعات پرداختش رو کنسل کنه. حالا فرآیند دیگه در اپلیکیشن شروع میشه برای کنسل کردن. پس یک ساگای دیگه میاد وضعیت این ساگا رو از وضعیت pending میبره به وضع کنسل. بعد ساگای اول که منتظر بود ادامه پیدا میکنه و فرآیند رو میبره جلو و سفارشی که مشتری کنسل کرده میره تو وضعیت Approve 
2- دسته dirty read: اطلاعاتی خونده میشه که میانه راه ساگای دیگه هست. یعنی اطلاعات انباری رو میخونیم که یک ساگای دیگه داره اون رو پردازش میکنه. یعنی داره یک اطلاعات کثیف رو میخونه و پردازش میکنه
3- دسته nonrepeatable read: خواندن های غیر قابل تکرار زمانی که دوبار میره سراغ یک اطلاعات و هر بار اطلاعات جدید بدست میاره. مثلا وقتی ثبت سفارش میکنه یک قیمتی میبینه و در همون ساگا لحظه پرداخت میره دوباره قیمت رو میخونه و این بار یک قیمت دیگه برای کالا میبینه


راه حل های رفع anomaly 
1- روش semantic lock: قفل معنایی داشته باشیم
2- روش  commutative update 
3- روش pessimistic view
4- روش Reread value 
5- روش by value


ساختار ساگا و انواع تراکنش ها (مرور)
1- تراکنش های compensatable
2- تراکنش های Pivot
3- تراکنش های retriable

1- استفاده از semantic lock
رکوردهایی که توسط ساگا تخت تاثیر قرار میگیرند رو یک flag براشون در نظر میگیریم و توسط اون به بقیه این هشدار رو میدیم که این رکورد در حال پردازش یک ساگا هست. حالا اگر براش مهم نبود اون اطلاعات رو فقط میخونه در غیر اینصورت صبر میکنه یا اصلا اون اطلاعات رو در نظر نمیگیره. این فلگ میتونه یک boolean باشه صرفا یا حالت مثلا stateهای pending باشه. 
مثلا اگر یک سفارش در حال پردازش هست دستور لغو بیاد اون دستور رو ریجکت میکنیم و میگیم امکان لغو این سفارش وجود نداره. 
ممکنه فرآیند retry در نظر بگیریم که اگر در حالت خاصی بود اینقد retry کنیم تا از حالت pending خارج بشه
عیب retry اینکه ممکنه بره تو حالت deadlock و اون فرآیند از حالت pending خارج نشه

2- روش commutative update

