در این دوره هم روش حل مسائل پیچیده رو صحبت میکنیم و هم روش حل مسائل ساده

وقتی ما به صورت OOO میریم جلو خب برنامه رو طراحی میکنیم ولی موقع پیاده سازی به چالش هایی میخوریم مثل اینکه چطوری از دیتابیس بخونیم یا توی دیتابیس بنویسیم یا مثلا چطوری تراکنش رو کنترل و مدیریت کنیم. لذا میریم سراغ الگو های DDD. پس مثلا میتونیم از Value object یا entity استفاده کنیم. 

الگو مدل سازی دامنه
تحلیلی که انجام دادیم رو تبدیل به کد کنیم. بدونیم چه کلاس هایی باید داشته باشیم یا مثلا چه اشیای باید داشته باشیم و هر کدوم چه روابط و وابستگی هایی با هم دارن 

یکی از این الگوهای مدل سازی دامنه entity هست
مدل Entity
وقتی ما کلاس ها مون رو طراحی میکنیم، هر کلاس پراپرتی ها و ویژگی های متفاوتی دارن که قابل تغییر هست. ولی یک ویژگی هست که تغییر نمیکنه و اون شناسه یا ID هست که اگر شناسه دو شی یکی باشه ما اون دو شی رو یکی در نظر میگیریم. 
وقتی ما reach domain model طراحی میکنیم این الگو به ما میگه که هیچ گاه اجازه ندین state داخلی شی به راحتی تغییر بکنه، باید یک سری متد و behavior داشته باشیم که به ازای اجرا شدن اون ها state داخلی اون تغییر کنه. مثلا سرعت حرکت خودرو خود به خود زیاد نمیشه، باد پدال گاز بیشتر فشرده بشه و سوخت بیشتر احتراق پیدا کنه که باعث بشه سوخت بیشتری سوزانده بشه. ولی آی دی هیچ گاه یکسان نباید باشه. مثلا میتوین eaqual and hashCode کلاس رو تغییر بدیم و بگیم اگر آی دی یکسان بود دو شی یکسان هست. با در نظر گرفتن این نکته ما مدل entity رو رعایت و پیاده سازی کردیم. 

 الگو Value Object
ما وقتی یک نرم افزار رو پیاده سازی میکنیم میرسیم به مفاهیمی که صرفا مقادیرش برای ما مهم هست و شناسه ای به تنهایی نداره. برای اینکه معنا پیدا کنه باید وصل شه به یک entity. مثلا وقتی از مفهوم پول صحبت میکنیم خودش به تنهایی بین دوتا پول هیچ تفاوتی نداریم، مثلا کهنه باشه یا جدید یا هرچی. وقتی معنا پیدا میکنه که به یک entity بچسبه. با تغییر ویژگی کل شی تغییر میکنه، مثلا علیرضا رو بکنیم علی دیگه کل شی عوض شده، یا مثلا دو هزارتومن رو بکنیم صد هزارتومن کل شی عوش میشه. کلا value object ها immutable هستند. اگر مقدارشون یکسان باشه یکسان در نظر گرفته میشن یعنی مساوی پس باید به یک entity بچسبند، مثلا دوتا هزارتومن با هم برابرند، ولی وقتی یکی از اونها میچسبه به موجودیت علی دیگه میشه هزارتومن علی و با اون یکی هزارتومن متفاوت میشه. معمولا برای value object یک کلاس جدا میسازیم و از premetive ها استفاده نمیکنیم برای مباحث Abstraction و عدم نشت لاجیک. 
مثال عملی:
مثلا کلاس person داریم. به جای اینکه بیایم نام و نام خانوادگی رو string بگیریم میتونی یک کلاس برای نام و یک کلاس برای نام خانوادگی داشته باشیم. اینطوری میتونیم validation های هر کدوم رو داخل کلاس خودشون چک کنیم و از یه عالمه کد تکراری جلو گیری کنیم. 


الگو Domain service
کلاس های entity و value object هیچ State ای رو نمیشه تغییر داد و فقط یک سری state رو دسته بندی کردیم. از طرفی وقتی یک behavior رو داخل یک entity میذاریم که اون Entity تمام اطلاعات لازم جهت پیاده سازی اون رفتار داشته باشه یعنی اصطلاحا information expert باشه. اگر بخوایم رفتار رو به زور داخل یک entity پیاده سازی کنیم باید یک سری اطلاعات بیشتر بهش بدیم که نهایتا باعث میشه coupling برنامه بره بالا و cohesion برنامه بیاد پایین. خوبه همیشه high cohesion باشیم و low coupling. باید بین اونها همیشه یه تعادلی برقرار کنیم. 
در نتیجه یک کلاس میسازیم و اطلاعات مورد نیاز رو بهش میدیم و منطقمون رو توش پیاده سازی میکنیم. این کلاس میتونه state برنامه رو هم عوض کنه. 
این کلاس یک بخشی از domain logic من که بابت رعایت اصول کوهیژن و کاپلینگ که به هیچ enitity و value object نمیچسبه رو پیاده سازی میکنه
این رو نباید با application service اشباه بگیریم چون کلاس application service کارش این هست که یک orchestration و هماهنگی بین use case ها داشته باشه. یا به عبارتی application سرویس اون فرآیند و flow و مدیریت میکنه و از domain logic ها استفاده میکنه. 
با این کار از **pure fabrication** که یکی از اصول GRASP هست استفاده کردیم. 


بحث modules
دسته بندی کردن کلاس ها 
کمک به فهم و نگهداری بهتر
این کار رو به کمک namespace ها انجام میدیم
حالا این کار رو میشه بر اساس بیزنس دسته بندی کرد و هم میشه این دسته بندی بر اساس نوع کلاس باشه مثلا domain service ها یک جا، entity ها یک جا دیگه و ...

الگو مدیریت چرخه حیات اشیا
نیاز داریم از کلاس هایی که از از کلاس هایی که قبلا ساختیم instance بسازیم و باهاشون کار کنیم. که شامل الگو های زیر هست
الگو aggregate برای ایکه یک محدوده داشته باشیم و جلو گیری کنیم از اینکه یک گراف از آبجکت های خیلی بزرگ داشته باشیم
الگو factories برای اینکه بتونیم اشیا جدید رو توی بیزنس خودمون ایجاد کنیم
الگو repository برای اینکه بتونیم این اشیا رو ذخیره کنیم تو دیتابیس یا واکشی کنیم

الگو aggregate
اگر یک ماشین رو در نظر بگیریم یک عالمه اجزا داره مثل موتور و گاز و دنده و ... که کنار هم کار میکنن و ماشین رو برای ما شکل میدن. در مورد اپلیکیشن هم همینه. یه عالمه entity و value object داریم که کنار هم قرار میگیرن و اپلیکیشن ما رو میسازن. 
مثلا یک فروشگاه رو در نظر بگیریم، یک customer داره، یک product و یک order و یک orderLine که همه این ها هم به هم راه دارن یعنی از order میتونی به customer برسیم. پس همه این ها یک واحد کاری رو میتونن شکل بدن. 

هر کدوم به تنهایی معنی ندارن و کنار هم دیگه اگر باشن سیستم خرید رو شکل میدن و یک کاری رو انجام میدن. اگر این کل رو چک کنیم و درست کار کنه میتونیم بگیم هر کدوم از این ها به درستی دارن کار میکنن. اگر واکشی قرار اتفاق بیفته همش با هم باید انجام بشه. یا اگر ذخیره سازی قرار صورت بگیره کلش با هم باید تو این ذخیره سازی شرکت کنند. 

تو مثال فروشگاه یک جاهایی بی ربط هستن به هم مثلا cusotmer هیچ ربطی به product نداره. مثلا بخوایم product رو لود بکنیم چرا باید customer هم لود بشه. اگر با هم بگیریم چندتا مشکل میخوریم
1- مشکل performance اگر بخوایم product رو لود کنیم باید حجم زیادی داده لود کنیم مثلا داده های customer
2- مشکل دوم cuncurency هست. مثلا اگر بخوایم نام یک product رو عوض کنیم باید اون رو با تمام وابستگی هاش لود کنیم. حالا یکی میخواد قیمت اون رو عوض کنه باز باید کل دیتای cusotmer ها رو لود کنه. و وقتی بخوان هر دو همزمان commit بکنن مشکل concurrency میخورن در صورتی که ارتباطی به هم ندارند. 

الگو aggregate یک یا چند entity رو که از نظر transactional و مفهوم invariant باید با هم کار کنند رو کنار هم قرار میده که بهش میگیم aggregate. معمولا aggregate ها رو توی یک ماژول ایجاد میکنیم به اسم aggregate. 

مثلا اگر یک order میخوایم ایجاد کنیم  باید orderlineهاش هم همون لحظه ایجاد کنیم. یا لاجیک یا invariant رو کجا باید چک کنیم که آیا این order و orderlineهاش ایجاد بشن. یک جایی باید باشه تا این لاجیک های به هم مرتبط رو پیاده سازی کنه مثلا با ایجاد order بیاد orderline هاش رو هم چک کنه یا مثلا اگر 13 به در هست هیچ order ثبت نکنه. یک جا باید داشته باشیم تا این قواعد رو چک کنیم توش یا entity های مرتبط رو با هم چک کنیم بسازیم یا لود کنیم. 

قواعد aggregate
تو aggregate ما چندین entity داریم ولی یکی از این موجودیت ها جایگاه بالاتری نسبت به بقیه داره و root قضیه هست و تا اون نباشه بقیه کاربردی ندارن. مثلا تو aggregate های order تا وقتی Order نباشه Order Line بی معنی هست. ما به این موجودیت میگیم aggregate root که خودش یک سری قواعد داره 
نکته دیگه اینکه ارتباط ها بین aggregate باید با شناسه انجام بشه نه خود شی. مثلا Order رو بخوایم به Customer وصل کنیم نمیایم شی customer رو بذاریم اونجا باید لیستی از int ها بذاریم که رفرنس هستند به اون customer
نکته دیگه اینکه شناسه aggregate root شرکت میکنه برای ارتباط، نمیتونیم مثلا شناسه order line  رو برداریم و توی aggregateهای customer استفاده کنیم. 
اگر دستوری بخواد اتفاق بیفته از طریق aggregate root اتفاق میفته. یکی از خارج مثلا نمیتونه بیاد order line ایجاد کنه. فقط order میتونه order line رو ایجاد کنه. 


الگو Factories
موقعی کاربرد داره که میخوای از کلاسمون شی درست کنیم. مثلا داریم از دیتابیس داده میخونیم. گاهی ساخت شی راحته و چند پارامتر بهش میدیم. ولی گاهی ساخت شی راحت نیست و قواعد زیادی باید رعایت کنیم. 