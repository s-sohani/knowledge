در این دوره هم روش حل مسائل پیچیده رو صحبت میکنیم و هم روش حل مسائل ساده

وقتی ما به صورت OOO میریم جلو خب برنامه رو طراحی میکنیم ولی موقع پیاده سازی به چالش هایی میخوریم مثل اینکه چطوری از دیتابیس بخونیم یا توی دیتابیس بنویسیم یا مثلا چطوری تراکنش رو کنترل و مدیریت کنیم. لذا میریم سراغ الگو های DDD. پس مثلا میتونیم از Value object یا entity استفاده کنیم. 

الگو مدل سازی دامنه
تحلیلی که انجام دادیم رو تبدیل به کد کنیم. بدونیم چه کلاس هایی باید داشته باشیم یا مثلا چه اشیای باید داشته باشیم و هر کدوم چه روابط و وابستگی هایی با هم دارن 

یکی از این الگوهای مدل سازی دامنه entity هست
مدل Entity
وقتی ما کلاس ها مون رو طراحی میکنیم، هر کلاس پراپرتی ها و ویژگی های متفاوتی دارن که قابل تغییر هست. ولی یک ویژگی هست که تغییر نمیکنه و اون شناسه یا ID هست که اگر شناسه دو شی یکی باشه ما اون دو شی رو یکی در نظر میگیریم. 
وقتی ما reach domain model طراحی میکنیم این الگو به ما میگه که هیچ گاه اجازه ندین state داخلی شی به راحتی تغییر بکنه، باید یک سری متد و behavior داشته باشیم که به ازای اجرا شدن اون ها state داخلی اون تغییر کنه. مثلا سرعت حرکت خودرو خود به خود زیاد نمیشه، باد پدال گاز بیشتر فشرده بشه و سوخت بیشتر احتراق پیدا کنه که باعث بشه سوخت بیشتری سوزانده بشه. ولی آی دی هیچ گاه یکسان نباید باشه. مثلا میتوین eaqual and hashCode کلاس رو تغییر بدیم و بگیم اگر آی دی یکسان بود دو شی یکسان هست. با در نظر گرفتن این نکته ما مدل entity رو رعایت و پیاده سازی کردیم. 

 الگو Value Object
ما وقتی یک نرم افزار رو پیاده سازی میکنیم میرسیم به مفاهیمی که صرفا مقادیرش برای ما مهم هست و شناسه ای به تنهایی نداره. برای اینکه معنا پیدا کنه باید وصل شه به یک entity. مثلا وقتی از مفهوم پول صحبت میکنیم خودش به تنهایی بین دوتا پول هیچ تفاوتی نداریم، مثلا کهنه باشه یا جدید یا هرچی. وقتی معنا پیدا میکنه که به یک entity بچسبه. با تغییر ویژگی کل شی تغییر میکنه، مثلا علیرضا رو بکنیم علی دیگه کل شی عوض شده، یا مثلا دو هزارتومن رو بکنیم صد هزارتومن کل شی عوش میشه. کلا value object ها immutable هستند. اگر مقدارشون یکسان باشه یکسان در نظر گرفته میشن یعنی مساوی پس باید به یک entity بچسبند، مثلا دوتا هزارتومن با هم برابرند، ولی وقتی یکی از اونها میچسبه به موجودیت علی دیگه میشه هزارتومن علی و با اون یکی هزارتومن متفاوت میشه. معمولا برای value object یک کلاس جدا میسازیم و از premetive ها استفاده نمیکنیم برای مباحث Abstraction و عدم نشت لاجیک. 
مثال عملی:
مثلا کلاس person داریم. به جای اینکه بیایم نام و نام خانوادگی رو string بگیریم میتونی یک کلاس برای نام و یک کلاس برای نام خانوادگی داشته باشیم. اینطوری میتونیم validation های هر کدوم رو داخل کلاس خودشون چک کنیم و از یه عالمه کد تکراری جلو گیری کنیم. 


الگو Domain service
کلاس های entity و value object هیچ State ای رو نمیشه تغییر داد و فقط یک سری state رو دسته بندی کردیم. از طرفی وقتی یک behavior رو داخل یک entity میذاریم که اون Entity تمام اطلاعات لازم جهت پیاده سازی اون رفتار داشته باشه یعنی اصطلاحا information expert باشه. اگر بخوایم رفتار رو به زور داخل یک entity پیاده سازی کنیم باید یک سری اطلاعات بیشتر بهش بدیم که نهایتا باعث میشه coupling برنامه بره بالا و cohesion برنامه بیاد پایین. خوبه همیشه high cohesion باشیم و low coupling. باید بین اونها همیشه یه تعادلی برقرار کنیم. 
در نتیجه یک کلاس میسازیم و اطلاعات مورد نیاز رو بهش میدیم و منطقمون رو توش پیاده سازی میکنیم. این کلاس میتونه state برنامه رو هم عوض کنه. 
این کلاس یک بخشی از domain logic من که بابت رعایت اصول کوهیژن و کاپلینگ که به هیچ enitity و value object نمیچسبه رو پیاده سازی میکنه
این رو نباید با application service اشباه بگیریم چون کلاس application service کارش این هست که یک orchestration و هماهنگی بین use case ها داشته باشه. یا به عبارتی application سرویس اون فرآیند و flow و مدیریت میکنه و از domain logic ها استفاده میکنه. 
با این کار از **pure fabrication** که یکی از اصول GRASP هست استفاده کردیم. 


بحث modules
دسته بندی کردن کلاس ها 
کمک به فهم و نگهداری بهتر
این کار رو به کمک namespace ها انجام میدیم
حالا این کار رو میشه بر اساس بیزنس دسته بندی کرد و هم میشه این دسته بندی بر اساس نوع کلاس باشه مثلا domain service ها یک جا، entity ها یک جا دیگه و ...

الگو مدیریت چرخه حیات اشیا
نیاز داریم از کلاس هایی که از از کلاس هایی که قبلا ساختیم instance بسازیم و باهاشون کار کنیم. که شامل الگو های زیر هست
الگو aggregation برای ایکه یک محدوده داشته باشیم و جلو گیری کنیم از اینکه یک گراف از آبجکت های خیلی بزرگ داشته باشیم
الگو factories برای اینکه بتونیم اشیا جدید رو توی بیزنس خودمون ایجاد کنیم
الگو repository برای اینکه بتونیم این اشیا رو ذخیره کنیم تو دیتابیس یا واکشی کنیم

الگو 