میخوایم الگو و معماری های داخل یک سرویس رو بررسی کنیم. فارغ از اینکه میکرو سرویس هست کلا یا نه. 

قبل اینکه اپلیکیشن رو بخوایم شروع کنیم باید اول ببینیم صورت مسئله چیه. مثل کوه یخ که نصفش زیر آب هست. باید ببینیم چی زیر آب هست. یعنی باید بیزنس رو خوب بشناسیم. 

وقتی اپلیکیشن رو میخوایم شروع کنیم نه توسعه دهنده بیزنس رو میشناسن نه تیم بیزنس فنی میدونن پس باید به یک زبان مشترک برسیم. 
روش سنتی اینطوریه که یک جلسه مشترک شکل میگیره و تیم بیزنس راه حلی که خود بلده رو ارائه میکنه و تیم توسعه اون رو پیاده میکنه حالا معلوم نیست بهترین راه هست و درست کار میکنه یا نه. 
ایرادات این روش
1- عدم یافتن مسائل پنهان
2- مدل سازی ناقص و اینکه به زبان مشترک نمیرسیم 
3- عدم انتقال مفاهیم پیچیده
4- متکلم وجده داشتن
5- بدون هدف

راهکار:
روش event storming
بدست آوردن big picture
بدست آوردن میکرو سرویس ها و bounded context 
این روش چابکه، خیلی رسمی ممکنه نباشه و فرموله نیست چون هدف اینکه بیزنس رو بشناسیم 

**حالا بعد اینکه بیزنس یک سرویس رو شناختیم توی اپلیکیشن چه معماری استفاده کنیم. بهتره سه لایه باشیم یا دامین متریک، معماری union یا exagon یا transaction metric. یا اینکه اصلا تمیز کد بزنیم یا اسباگتی بزنیم بریم**


معیار SOC یا seperation of concern، هر اپلیکیشنی باید این معیار رو رعایت کنه تا بگیم اون اپلیکیشن تمیز نوشته شده. این غلطه بگیم چون میکروسرویس هستیم پس تو لایه اپلیکیشن هر طور زدیم مهم نیست چون برنامه کوچیکی هست. این تفکر بلند مدت معماری رو کثیف میکنه علاوه بر این تضمینی نیست که یک سرویس یک ماه تموم بشه یا یک سال و حجم کدش چقدر باشه. پس همیشه باید این معیار رو رعایت کرد و تمیز کد و معماری سطح اپلیکیشن رو انجام بدیم
1- جلوگیری از تبدیل شدن به BBM
2- جلوگیری از تصعیف یک پارچگی برنامه
3- حفظ سودمندی مدل دامنه
4- جداسازی پیچیدگی فنی از کسب و کار
5- دلایل و فرکانس تغییر کاملا متفاوت مثلا احتمالا تغییر دیتابیس خیلی کمتر است از مثلا تغییر سیستم پیام رسانی
6- بخش های مختلف جدا می شوند. اگر به خوبی بخش های نرم افزار جدا باشه به راحتی میشه یه بخش رو تغییر یا جایگزین کرد


معماری layered architecture
هر وظیفه را در لایه اخت





